[{"title":"Web push 浏览器推送","url":"/2019/03/17/web-push/","content":"\nWeb push 是PWA的关键技术之一，最近详细了解了一下 Web push 的原理及实现。\n\n## 原理\n\n借用W3C Push api文档上的一张图：\n\n![](/images/2019/web-push/sequence_diagram.png)\n\n上图中的 web page、serice worker、user agent 为浏览器端；浏览器端和push service之间的连接基于  [Web Push Protocal](https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol?spm=ucplus.11213647.0.0.12df6fe7phMPnU) 实现，由浏览器厂商自行实现，比如Chrome使用的[FCM](https://firebase.google.com/docs/cloud-messaging/concept-options?hl=zh-cn)作为push service 所以注定在国内无法使用；application server 就是我们自己业务的服务，用于通知触发FCM给浏览器发送推送消息，这是唯一业务开发者可以参与的部分。\n\n## 实现\n\n### 业务服务端 (application server)\n\n服务端的实现借助 Node.js [web-push](https://github.com/web-push-libs/web-push#readme) SDK 来做，因为[Web Push Protocal](https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol?spm=ucplus.11213647.0.0.12df6fe7phMPnU) 还是很复杂的，该SDK帮我们处理了复杂的协议，我们只需要轻松调用即可。\n\n```javascript\nconst webpush = require('web-push')\nconst Koa = require('koa')\nconst cors = require('@koa/cors')\nconst Router = require('koa-router')\nconst koaBody = require('koa-body')\nconst { publicVapidKey, privateVapidKey } = require('./key')  // 钥匙对通过命令下 web-push generate-vapid-keys 来生成，是 web push 协议的一部分，这里提供简单的方法供我们生成\n\nconst app = new Koa()\nconst router = new Router()\nlet subscription\n\n// 设置 VAPID , 这里用到的 VAPID 规范，用于Push service 通过该规范来做身份验证\nwebpush.setVapidDetails('mailto:i@ice.gs', publicVapidKey, privateVapidKey);\n\n// 启动 http 服务器\napp.use(cors())\n  .use(koaBody())\n  .use(router.routes())\n  .use(router.allowedMethods())\n\n// 浏览器端通过该接口上传，订阅信息 subscription\nrouter.post('/subscribe', (ctx, next) => {\n  console.log('ctx', ctx)\n  subscription = ctx.request.body\n  ctx.response.status = 200\n  ctx.body = subscription\n});\n\n// 调用该接口即发送消息，依赖上一步得到 subscription，触发通知 Push service 给浏览器发送推送\nrouter.get('/push', async (ctx, next) => {\n   ctx.body = await webpush.sendNotification(subscription, JSON.stringify({ title: 'test' }))\n});\n\napp.listen(3000);\n```\n\n\n\n### 浏览器端\n\nindex.html\n\n注意，访问该页面，需要  https ，可以自行本地搭建一个 https 的静态服务器\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n\n  <script src=\"./client.js\"></script>\n</body>\n</html>\n```\n\nclient.js\n\n推送的订阅和订阅信息上传到 application server，在 client.js 中进行\n\n```javascript\n// 将字符串转换成 Uint8Array 的方法\nfunction urlBase64ToUint8Array(base64String) {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4);\n  const base64 = (base64String + padding)\n    .replace(/-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = window.atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n\n\n// 这里的 publicVapidKey， 就是上文application server端生成的 publicVapidKey\nconst publicVapidKey = 'BEARBIG3egr2oiv2MVr_UzfxI3GdbVi5w1SOg6hlvAbwlbjdbjEenOVVlIPva8HOe';\nif ('serviceWorker' in navigator) {\n  console.log('Registering service worker');\n  run().catch(error => console.error(error));\n}\nasync function run() {\n  console.log('Registering service worker');\n  // 注册 service worker\n  const registration = await navigator.serviceWorker.\n    register('/code/cu-web-push/browser/worker.js', {scope: '/code/cu-web-push/browser/'});\n  console.log('Registered service worker');\n  console.log('Registering push');\n  \n  // 通过浏览器API注册消息订阅\n  const subscription = await registration.pushManager.\n    subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: urlBase64ToUint8Array(publicVapidKey)\n    });\n  console.log('subscription', subscription)\n  console.log('Registered push');\n  console.log('Sending push');\n  // 注册完成后，将注册信息提交给 application server\n  // 之后请求调用 http://127.0.0.1:3000/push 浏览器端即可收到消息推送\n  await fetch('http://127.0.0.1:3000/subscribe', {\n    method: 'POST',\n    body: JSON.stringify(subscription),\n    headers: {\n      'content-type': 'application/json'\n    }\n  });\n}\n```\n\nworker.js\n\n监听 push service 发送消息到浏览器和发送系统通知，通过 service worker 来实现\n\n```javascript\nconsole.log('Loaded service worker!');\n// 监听 `push` 来获取 push service 发来的推送\nself.addEventListener('push', ev => {\n  const data = ev.data.json();\n  console.log('Got push', data);\n  // 收到推送，调用 Notification 接口，发送系统通知\n  self.registration.showNotification(data.title, {\n    body: 'Hello, World!',\n    icon: ''\n  });\n});\n```\n\n## 兼容性\n\n目前兼容性并不乐观，可以在 caniuse 查看兼容情况，大体上只有 Android端和PC端的 Chrome、Firefox 支持，IOS端和Safari不支持。而且Chrome 国内无法使用，无解。\n\n## 参考资料\n\n* [Web Push Notifications](https://developers.google.com/web/fundamentals/push-notifications/)\n* [Web Push 介绍](https://dev.ucweb.com/docs/pwa/docs-zh/qo27fv?spm=ucplus.11213647.toc.5.7bfa4ed0LgjJ5O)\n* [Web Push Protocal](https://tools.ietf.org/html/draft-ietf-webpush-protocol-12)\n* [Push api](https://www.w3.org/TR/push-api/)\n* [Web Push Node.js SDK](https://github.com/web-push-libs/web-push#readme)","tags":["web development"]},{"title":"关于小程序的思考","url":"/2019/03/16/about-mini-app/","content":"\n最近的做的一些项目和各种国内小程序有关，把国内主流的小程序（微信、百度、头条、快应用、支付宝）都体验一遍，自己有一些感想。\n\n## 小程序降低了开发门槛？\n\n记得在微信小程序刚出来时，标榜的优势之一就是降低开发门槛，一个产品经理即可完成开发。但是作为一个职业前端开发，对这些并不能苟同，有以下一些原因：\n\n* API 设计不合理。远远达不到 W3C API 设计的能力，而且和 W3C 标准不同；甚至有些API的设计相当原始，已经远远跟不上现代JS语言；对开发者来说带来的是困惑和使用成本；\n* 开发工具不稳定，开发调试并不简单。微信小程序算是比较成熟的，IDE开发调试还算能用，但是其他小程序照本搬抄，草草做个IDE就给开发者用，连基本的可用都达不到，更别提开发体验了。这里最气愤的是快应用，个人觉得快应用的想法是很好的，但是开发体验做的相当差。差到气愤！\n\n## 小程序降低了研发成本？\n\n小程序出来之前，我们需要开发一个产品的三端，现在我们需要开发四端，甚至七端、八端的。无疑需要更多的人力投入。\n\n## 小程序提升了体验？\n\n在功能上小程序一般比 H5版本的功能少，更别提和Native 应用比较。在性能上并不觉得比H5好多少，但是在启动速度上感觉比H5更慢。个人觉得综合下来小程序的体验还不如 H5，下面会继续探讨这个问题。\n\n## 大家为什么还开发小程序？\n\n为了流量，诸如以上提出的那么多问题，但是很多公司、人都还要开发小程序，当然有最现实的原因，为了通过小程序平台来作为流量入口。\n\n## 我认为的未来？\n\n从一些声音中听到，有人认为小程序是未来，有人甚至想把小程序方案提交到WEB标准中。我觉得小程序不管对于开发者、用户都是没有好处，唯一好处是商业公司通过这种方式短暂获取流量，获取短暂的利益（长期来讲，如果小程序成为了一个公司产品的主要入口，进而变成被国内某家公司控制）。\n\n个人觉得小程序方案，应该随着时间和技术的推进，被埋没在历史的长河中。\n\nPWA，我一直觉得PWA才是未来移动端、PC端应用开发的主流方案，虽然WEB标准也主要由主要几家公司主导，但是相对来说是集体的智慧，是更加理想和良好的设计。觉得PWA技术是未来的原因有以下几点：\n\n* Web 性能就目前而言，已经不再比Native差，还是说 VSCode 就是个很好的例子。而且随着浏览器优化和性能的提升未来Web性能会更加优秀。目前出现 Weex、Fluter 方案，用Native渲染来提升性能，但是浏览器在未来也可能达到Native渲染的性能、能力，我们就根本不需要这些中间方案。\n* 能力，诸如通知推送、离线等能力 PWA应用已经具备，可以基本达到Native同等能力\n* 标准，PWA是Web标准，只有成为标准的东西，才可能被延续使用。PWA技术只是Web标准的一种延伸，并不会对开发、调试等等带来额外的成本\n\n为什么PWA应用没有普及？\n\n在国外PWA应用已经得到广泛的应用，PWA技术的主要推动者是 Google，但是Google服务无法再国内使用，比如推送能力，国内就无法使用；用户使用习惯养成后难以改变，国内目前用户习惯为APP为主，PWA并没有成为一种习惯，甚至大部分普通用户重来没有用过也不知道PWA是什么，这个需要时间和契机来改变。\n\n尽管这些，我依然觉得PWA是未来，并想为推动PWA的发展做出努力！\n\n\n\n","tags":["web development"]},{"title":"对编写JavaScript代码的理解","url":"/2018/11/27/\bHow-to-write-JavaScript/","content":"\n## 前言\n\n从14年7月开始从事前端开发至今已经有4年多的时间，从入行的很长时间里，觉得自己都还没入门。直到最近的某个时间回想，觉得现在的自己可能算是入门了。\n\n期间参与过多家互联网（科技）公司的前端开发工作，经历过10w+ JavaScript 项目的洗礼，修过一年的BUG、写过富文本编辑器、WebAPP、Hybird APP、JS库等等，也和很多个前端开发者合作过，查阅学习过很多人的代码。其实目前得到的结论是，由于JavaScript的入门门槛过低（自己也是因为这个原因入行），导致JavaScript的代码质量普遍偏低。所以想用自己的入门经验来给那些从事JavaScript开发，但是尚未入门的人一些经验的分享。\n\n大多为个人实践的思考和总结，可能也会存在一些理解偏差和差异，\b希望可以指正。\b\b\n\n## \b如何评判代码质量\n\n可能一直以来代码质量都是一个虚的表述，没有可以遵循的标准来衡量一份代码的质量。但是在实践中我们会得到一些\b依据。\n\n* 是否可维护\n* 是否\b易扩展\n* 是否易重构\n* 是否边界异常情况处理的到位\n* \b是否优化了性能、运行是否高效、内存是否\b有效管理和占用\n* 是否单元测试覆盖，及高覆盖率\n\n## 编程原则\n\n* \b复用：最大化的复用\b，而不是\bCopy\b相同的代码，保证极低的代码重复率\n* 模块（组件）化：问题分解，把大的问题，分成若干个小问题去处理，保证一个函数（类）只做一件事的原则，降低复杂度\n* \b数据操作分离（松耦合）：每个类（函数）都是一个独立的机器，\b注入数据得到实例或得出结果，\b不依赖\b\b任何外部状态\n* 注重运行效率：保证代码以较高的效率运行，并持续优化\n\n## \b编程方法\n\n在目前的大多数实践中，是以\b类的继承的**面向对象编程**为基础加上**函数式编程**来构成整个项目。\n\n### 继承\n\n\b其实不管是ES6的Class概念出现之前还是之后，JavaScipt 大型工程的继承大多都是基于类的概念来实现，Class的出现，使我们可以更加显式的使用类，即面向对象的编程的思想来实现继承。\n\n### 复用\n\n类用处在于继承，而函数则是复用。当一个函数被考虑要复用的话，就需要把这个函数写成一个无状态的纯函数，\b自身只接收数据，\b然后返回新的数据。只是一个处理数据的机器\n\n### 封装\n\n即将常用的多个逻辑语句（或者函数）封装为一个公用函数或者一个公共的类，提供方便的调用方式，这样可以更好的复用，降低重复率，对提高可维护性有重要意义。（这里所说的封装仅仅是一种描述形式，有别于传统编程语言中的封装概念）\n\n### 依赖注入\n\n依赖注入的思想在`Angular`、`Vscode` 中被广泛使用，将运行时的依赖通过参数的形式注入进实例中，这种方式有点类似函数式编程，可以保持实例的松耦合，每个实例都是一个独立的机器，会使得逻辑清晰，依赖清晰，利于维护。\n\n### 内存管理\n\n虽然JavaScript的引擎都有内存回收机制，但是想要控制良好的内存占用，必须手动来管理内存（VSCode 就是个很好的例子），主动的来清理和消除不必要的内存暂用，可以对整个JavaScript的性能和运行效率有很好的提升。\n\n比如一些异步方法、定时器、大的数据量变量等，我们必须根据使用逻辑来主动销毁，否则就会带来问题和不必要的内存占用。\n\n### 执行效率\n\n其实我们在写每一段代码时，都需要去思考和考量这段代码是否高效。考虑如何降低时间复杂度、如何通过最短路径求解、是否可应对极端情况、是否可以分场景提高运行效率\n\n## 代码保障\n\n其实有一些现实案例值得我们思考，为什么普遍IOS应用比Android应用质量（指的运行效率、稳定性、BUG量等）高，为什么React写出的代码容易维护、重构、拓展。其实我们从人的这一方面来保障代码的质量是不可靠的，必须上升到工具方面、底层框架设计方面、系统层面，才是靠谱有效的保障。\n\n### Typescript\n\n目前JS还没有较好的底层框架、系统层面的保障。其中Typescript算是一种目前比较好的从语言层面的保障。“Javascript 不适合编写大型项目”，而Typescript 使得 JavaScript 可以编写大型项目。\n\n### JSLint、TSLint、ESLint\n\n这些 Lint 一方面可以规范代码样式，另一方可以规范一些逻辑，对代码质量起到基础保障的作用，建议项目均开启基础的Lint规则，也可以参照业内成熟的规则范例。\n\n### 单元测试 自动化测试\n\n当项目足够庞大复杂时，单元测试是必不可少的，否则在维护迭代中，很难保证代码修改后整个项目的稳定性。自动化测试有时候和项目的运行模式、依赖等有关不容易实现，但是自动化测试如果实现了，将会是更好的一层保障，基本可以保证可用性和稳定性交付。\n\n### 保持头脑清醒\n\n一般低级错误和BUG都是在自己头脑不清醒的时候产生的。比如一直加班到12点，头脑浑噩的准备最后提交一次代码，赶紧回家睡觉的时候；比如上线后的紧急修复线上BUG的时候。在紧张或者困乏头脑不清醒的时候写出来的代码是最容易携带问题进去的。所以我们要时刻保持清醒和镇定，如果无法镇定下来，可以暂时停止，找个自己可以调整的方式，短暂的调整之后再重新进入编码。\n\n### Code review\n\n刚开始对Code review 是拒绝的，自己的代码被别人说三道四终归还是不爽，经常和Review者“干”起来，好多GitHub上的Pull request 也会经常看到两个人“干”起来。一味地“蛮干”是完全没有意义而且浪费时间的，拿证据、摆事实、讲道理说服对方或者接受对方的意见才是正确的做法。\n\n当你遇到一个负责任的Review者的时候，会帮你规避很多BUG，比如逻辑错误、不严谨、误用等等被自己忽略的问题，可能也会学到一些编码技巧、编码规范， 这个过程其实也是开发者间交流成长的一个契机。一旦尝到甜头，之后你会需要甚至依赖Code Review。\n\n## 一些想法\n\n### 沟通\n\n实际开发中沟通可能会占据大量的时间，个人觉得沟通需要遵循这样的原则，优先在线非实时沟通（gitlab issue commit 等）其次邮件通信工具沟通，最后才是面对面沟通。\n\n面对面沟通其实很容易造成低效，而且会粗暴打断对方节奏，不是必须应尽量避免当面沟通。线上沟通更容易让自己深入思考，理清思路，突出需要沟通问题，往往有些时候在你梳理问题的时候，自己就把问题解决了，而无需去沟通。\n\n非当面沟通的一个好处就是不易打断对方，所以在充分分析自己的问题之后，言简意赅的将自己问题发给对方，并给对方一定的处理时间，不要一味的催促，才是比较好的方式。\n\n前端开发者有个比较常见的沟通场景，和后端联调接口。这个场景比较科学的实施应该是这样的：\n\n* 前后端其中一方书写接口文档，另一方Review确认\n* 前端后端分别开发，Mock数据或Mock请求，双方只对文档负责，相互无任何其他依赖\n* 前后端均开发完成，将Mock接口切回测试环境接口，做回归\n* 对回归测试出的少量的异常，前后端做简单沟通即可\n\n其实在这个场景中前端需要沟通的东西是不多的，但是在实践中会发现好多开发者的大量时间浪费这上面。\n\n沟通的态度也是很重要的，多用敬语、多谦让和理解、对人友善才会得到友善对待。\n\n### 注释\n\n曾经看到过这样一句话，大意是“好的命名，可以减少注释”。还是比较认同这句话，首先我们注重变量、函数、类的命名，减少不必要注释。只在难以理解的逻辑和特殊处理的逻辑处写少量的注释。只写必要注释，注释太多影响整个代码的可读性，而且如果注释没得到有效维护，在逻辑变更后反而引起了误解。\n\n### 文档\n\n文档应该是代码最好的伙伴，文档可以极大的降低沟通成本、维护成本并且可以帮助梳理思路等等。\n\n### 编程理解\n\n* 当发现一个自己参与的项目，可以轻松的定位问题，轻松的重构、轻松的拓展，这个时候就可以享受编程的过程，把更多的精力花费在算法优化、工程优化上。\n\n* 代码写到最后，会发现自己只是在写声明配置文件而已。将函数或者类定义，然后定义参数，然后串联起来，然后实现函数或类的细节，仅此而已。\n* 代码质量是受个人性格、当时状态影响的。道理都懂，就是时间赶任务重，而做不到。所以我们要在平时养成良好的习惯，这样即便在高压状态下也会基本按照好的习惯来编码。好的编码习惯绝对是节省时间而不是浪费时间。\n* 编码期间，不要试图通过不断的试错来解决自己不了解的问题，所有的不了解最终都会回归到交付期的BUG。自己挖的坑，还是自己进。所以一定要对编码的周边API、环境、用法等做的十分的熟悉，不留盲点。","tags":["web development"]},{"title":"本地开发启用HTTPS","url":"/2018/11/22/本地开发启用https/","content":"\n现在众多网站或者浏览器的API都需要启用HTTPS，本地如果无法启用HTTPS就会有诸多开发的不便。\n\n其实本地开发启用HTTPS只需要简单几步就可以搞定：\n\n## 生成加密证书对\n\n\b执行以下命令\n\n```shell\nopenssl req -x509 -out localhost.crt -keyout localhost.key \\\n  -newkey rsa:2048 -nodes -sha256 \\\n  -subj '/CN=localhost' -extensions EXT -config <( \\\n   printf \"[dn]\\nCN=localhost\\n[req]\\ndistinguished_name = dn\\n[EXT]\\nsubjectAltName=DNS:localhost\\nkeyUsage=digitalSignature\\nextendedKeyUsage=serverAuth\")\n```\n\n其中的 \b`DNS:localhost` \b\b字段中的`localhost`替换成通过\bhost绑定到 `127.0.0.1` 的任意域名比如我们在host中设置了\n\n```\n# My hosts\n127.0.0.1 dev.dev\n```\n那么就可以为`dev.dev` 这域名设置证书\n\n```\nopenssl req -x509 -out localhost.crt -keyout localhost.key \\\n  -newkey rsa:2048 -nodes -sha256 \\\n  -subj '/CN=localhost' -extensions EXT -config <( \\\n   printf \"[dn]\\nCN=localhost\\n[req]\\ndistinguished_name = dn\\n[EXT]\\nsubjectAltName=DNS:dev.dev\\nkeyUsage=digitalSignature\\nextendedKeyUsage=serverAuth\")\n```\n\n\n## 信任证书\n\n命令执行完就会生成`localhost.crt` `localhost.key`，双击 `localhost.crt` 就会在`钥匙串` 中打开，选择导入证书（Mac OS 10.13 中会提示选择导入证书，10.14会直接导入），找到名为`localhost`的已导入证书后，设置信任，如下图\n\n![](/images/2018/11/https-crt.png)\n\n## 启用相应的服务器\n\n以用`http-server`启动静态服务器为例\n\n```\nsudo http-server -S -K localhost.key -C localhost.crt -p 443\n```\n\n启动成功后\b\b用Chrome、Safari浏览器访问即可看到如下效果，Firefox 有点任性，访问起来还是会提示不安全。\n\n![](/images/2018/11/https-open.png)\n\n\n## 参考文章\n\nhttps://letsencrypt.org/docs/certificates-for-localhost/","tags":["web development"]},{"title":"组装一台黑苹果","url":"/2018/10/14/一台黑苹果/","content":"\n发烧然后退烧，就组装的一台黑苹果。采用的开放式机箱（某宝亚克力机箱）。\n\n感觉整体的流畅度比我13年的MacBook Air 和 17年的 MacBook pro （i7双核 16g）都要流畅。\n\n![](/images/2018/mock-mac/pc0.jpeg)\n![](/images/2018/mock-mac/pc1.jpeg)\n![](/images/2018/mock-mac/pc2.jpeg)\n\n## 硬件\n\n配件全部\b从某宝购买\n\n* 主板：华硕 Z370-P\n* CPU：I5-8400\n* CPU风扇：买的CPU配的有\n* 硬盘：影驰 铁甲战将240G 7mm/SATA3\n* 内存：影驰 Gamer DDR4-2400/3000 8G \n* 显卡：影驰 GeForce GTX1050Ti 大将 4G \n* 电源：鑫谷核动力S7\n* 机箱：开放式亚克力机箱\n\n\n## 系统\n\n10.14 系统虽然已出，但是黑苹果的适配还不完善，\bN卡驱动也还不支持，所以目前按照的比较成熟的10.13\n\n### 系统镜像\n\n镜像从[黑果小兵下载 10.13.6](https://blog.daliansky.net/macOS-High-Sierra-10.13.6-17G2112-Release-Special-with-Clover-4606-original-mirror.html)\n\n### 刻录镜像到U盘\n\n使用 Etcher 直接将下载的镜像刻录到U盘\n\n### 引导安装系统\n\n开机选择U盘启动，进入安装界面，进行安装。\n\n> 如果无法引导到安装界面，可于Clover主界面-Options-Graphics进行显卡仿冒\n\n### 安装驱动等\n\n安装\bN卡驱动：\n\n> bash <(curl -s https://raw.githubusercontent.com/Benjamin-Dobell/nvidia-update/master/nvidia-update.sh)\n\n安装四叶草及其他驱动：\n\n下载 [MultiBeast 10.4.0 - High Sierra](https://www.tonymacx86.com/resources/categories/tonymacx86-downloads.3/)\n\n\n![](/images/2018/mock-mac/04.jpg)\n\n## 后记\n\n目前看起来除了CPU显示未知以外，没有发现其他问题。\n\n\n## 参考资料\nhttps://blog.daliansky.net/macOS-High-Sierra-10.13.6-17G2112-Release-Special-with-Clover-4606-original-mirror.html\n\nhttps://www.tonymacx86.com\n\n\n\n","tags":["os"]},{"title":"ES6 Modules in Chrome 61 +","url":"/2017/11/04/ES6Moudles/","content":"\n在Chrome 61+ 中尝试使用ES6 Modules\n\n### Index.html\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title>\n</head>\n<body>\n  <p>2+3 = <span class=\"result\"></span></p>\n  <script type=\"module\">\n    import { add } from './common.js'; \n    (function () { \n      document.querySelector('.result').innerText = add(2, 3); \n      console.log(add(2, 3));\n    }());\n  </script>\n</body>\n</html>\n```\n\n### Common.js\n\n```\nconsole.log('common.js');\nexport function add (a, b) {\n    return a + b;\n}\n```\n\n### Run\n\n[Click it](https://codepen.io/GGICE/project/editor/ZwBqyg)\n\n","tags":["web development"]},{"title":"Nginx 开启支持 HTTP2","url":"/2017/06/17/nginx-qi-yong-http2-2/","content":"\n## HTTP2的好处\n\n* Server Push 主动推送资源 （目前nginx还不支持，新版本nodeJs可以配置实现）\n* 用帧二进制编码传输数据，连接可以承载任意数量的双向数据流 (所以不用关心，请求的数量了)\n* 头部压缩，减少请求时间\n\n## 版本要求\n\nNginx 1.9.5 及其以上版本\n\n## 配置\n\n其实配置很简单，只需要在原本配置的`listen`处加入 `http2` 的声明即可，而且对无法支持HTTP2的浏览器，nginx会做自动降级处理。\n([Nginx 官方说明](https://www.nginx.com/blog/nginx-1-9-5/))\n\n```\nserver {\n    listen 443 ssl http2 default_server;\n\n    ssl_certificate    server.crt;\n    ssl_certificate_key server.key;\n    ...\n}\n```\n\n## 查看网站是否启用HTTP2\n\n在chrome控制台的Network中开启Protocol即可查看请求类型\n![](/images/2017/06/http2-1.png)\n\n成功开启HTTP2，将会出现h2的标记\n\n![](/images/2017/06/http2-2.png)\n\n## 为什么会开启失败\n\n几个月之前就将树莓派上的Nginx配置支持HTTP2，后来部分服务迁移到某国外服务器，直接将Nginx配置Copy过去却发现没有生效。\n\n为什么会开启失败，首先第一个Nginx的version一定要对，在version正确的前提下，修改配置文件后，其实我们已经完成开启HTTP2。\n\n但是如果Nginx所在操作系统OpenSSL Version为1.0.1x, Nginx基于这些版本 的OpenSSL编译，将会支持\n`NPN`而不支持`ALPN`，而新版的Chrome 只支持`ALPN`，所以如果是这种情况在Chrome浏览器中HTTP2依然不会生效。\n\n[Nginx官方说明](https://www.nginx.com/blog/supporting-http2-google-chrome-users/)\n\n在[serverfault.com](https://serverfault.com/questions/775298/debian-jessie-nginx-with-openssl-1-0-2-to-use-alpn-rather-than-npn)也有网友给出了解决方案（debian 系统）\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n> \n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.","tags":["web development","nginx"]},{"title":"BFC、IFC","url":"/2017/06/12/bfc-ifc-2/","content":"\n\n参考w3c [visual-model-intro](https://www.w3.org/TR/CSS2/visuren.html#normal-flow) 章节,  9.4 Normal flow\n\n## BFC 块级格式上下文\n\n### 形成BFC的情况\n\n* 浮动的元素\n* 绝对定位的元素\n* `overflow`不为`visible`的元素 （除非该值已经被传播到视口, 比如`body`元素设置`overflow`的情况）\n* 不是区块盒子的块容器（比如 `inline-blocks`,`table-cells`,`table-captions`）\n\n### BFC的布局规则\n\n* 在BFC中，元素从包含块的顶部开始，一个接一个的垂直排布\n* 在BFC中，两个兄弟盒之间的垂直距离由`margin`属性决定\n* 在BFC中，相邻的块级元素垂直边距会发生合并\n* 在BFC中，每个盒子的左边触碰包含块的左边缘（若从右到左格式，则右侧接触）。即使是浮动元素情况也是如此, 除非盒子建立了一个新的BFC环境\n\n最后一条，有些难理解，看下下面的例子：\n\n默认情况下p标签是触碰包含块的左边缘排列的，当我们设置p为新的BFC时，p标签就不会贴着左边缘排列了\n\n[🌰](https://codepen.io/GGICE/pen/XgXRbR)\n\n### BFC可以解决的问题\n\n* 布局问题\n* 清除浮动\n* 防止垂直边距合并（两个相邻BFC垂直边距不会发生合并）\n\n## IFC 行内格式上下文\n\n### 形成IFC的情况\n\n当一个块级内容盒子的内容只有行内元素时就形成了一个行内格式上下文环境\n\n### IFC的布局规则\n\n*  在IFC中，元素从包含块的顶部开始，一个接着一个的水平排列(包含这些行内元素和和形成的框组成的长方形区域称为`行盒`)\n*  这些内部元素的横向`margins`，`borders` 都会生效\n*  这些内部元素可以以不同的方式对齐 （基于底部、顶部或者基线对齐）\n*  行盒的宽度由包含块决定，行块的高度由行[高度计算](https://www.w3.org/TR/CSS21/visudet.html#line-height)部分中给出的规则确定\n*  行盒的高度总是足够高足以包含所有的盒子，但它可能高于包含的最高的盒子（不同的定位方式可能导致），当包含盒子的高度小于行盒时盒子的垂直对齐方式由`vertical-align`确定\n*  当多个行内级别的盒子不能水平放置在一个行盒张中时，他们会分布在一个或多个垂直堆叠的行盒中\n*  通常，行盒的左边缘接触包含块的左边缘，右边缘接触其包含块的右边缘。但是，浮动元素可能在浮动盒子边缘与行盒边缘之间，因此，虽然同一IFC中的行内盒子通常具有相同的宽度，但是他们的宽度会因浮动元素而减少，在同一IFC种的行盒的高度可能不同（例如一行是图片，一行是文本）\n*  当行内盒子的总宽度小于包含他们的行盒的宽度时，他们在行盒中的水平分布由`text-align`确定，如果该属性的值为`justify` , 则用户代理可以在行内盒子（除了inline-table 、inline-block的盒子 ）中展开空格和单词。\n*  当一个行内盒子的宽度大于行盒时，它会被分成几个盒子，这些盒子分布在多个行盒中，如果行内盒子不能被拆分（单个字符、特殊单词不允许中断、`nowrap`、`pre`）行内盒子则会溢出行盒；`margins`, `borders`, and `padding`出现在分割处没有视觉效果\n*  由于双向文本处理多个行内元素也可能被分割到同一个行盒\n*  在IFC中存在行内级别的内容就会创建行盒，如果行盒里面没有文字、不包含空格、没有margins, padding, or borders 非0的元素，没有其他 in-flow 内容（比如images，inline blocks 和 inline tables），并且不以换行符结束，将视为高度为0的行盒，也被认为是没有意义的\n\n### BFC可以解决的问题\n\n* 布局问题\n\n## 参考\n\n参考w3c visual-model-intro 章节, 9.4 Normal flow\n","tags":["web development"]},{"title":"基于JWT的登录验证系统实现","url":"/2017/06/01/ji-yu-jwtde-deng-lu-yan-zheng-xi-tong-shi-xian/","content":"\n## 概述\n\n 基于JWT的简单登录认证流程图：\n\n![](/images/2017/06/jwt-1.png)\n\n## JWT\n\n> JSON Web token（JWT）是一种开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于将各方之间的信息安全地传输为JSON对象。该信息可以通过数字签名进行验证和信任。使用密匙 （使用哈希算法）或使用RSA的公钥/私钥对可以对JWT进行签名。\n\njwt是对于token认证方式的一种规范和描述。\n\n#### JWT 的构成\n\njwt由三部分构成，并用`.`作为间隔：\n\n* Header\n* Payload\n* Signature\n\n看起来像这样 `xxxxx.yyyyy.zzzzz`\n\n##### Header\n\nHeader用来描述token类型和加密算法(HMAC、SHA256、RSA 等)，如下：\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n##### Payload\n\n这部分用来放置token的有效信息，有`reserved，public，private`三种类型：\n\n* **Reserved claims：** 一些保留类型的，推荐但不强制必须使用，包括以下属性\n  * **iss**: jwt签发者\n  * **sub**: jwt所面向的用户\n  * **aud**: 接收jwt的一方\n  * **exp**: jwt的过期时间，这个过期时间必须要大于签发时间\n  * **nbf**: 定义在什么时间之前，该jwt都是不可用的.\n  * **iat**: jwt的签发时间\n  * **jti**: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。\n* **Public claims：** 可以随意定义的属性, 但为了避免冲突，他们应该使用 IANA JSON Web Token Registry 定义或使用 URL 定义。\n* **Private claims:** 这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明。\n\n一个Payload看起来像这样\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n##### Signature\n\n将Header、Payload编码后加上secret，并用Header声明的算法进行加密，看起来伪代码的实现是这样的\n\n```javascript\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n\n##### 把三部分组合起来\n\n最终的样子像这样\n\n```javascript\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n```\n\n## 实现登录认证\n\n#### 服务端\n\n[jwt.io](jwt.io)网站提供众多后端语言的支持库，帮我们封装好了jwt的一些具体实现，其中包括Node.js的[node-jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) 。\n\n##### 生成token\n\n`jwt.sign(payload, secretOrPrivateKey, [options, callback])`\n\n`jwt.sign` 方法中的`secretOrPrivateKey`即为JWT第三部分`Signature`中的secret, 它既可以是一个复杂的字符串，也可以是一对密钥对中的`PrivateKey`。\n\n```javascript\nvar privateKey = fs.readFileSync(config.privateKey)\nvar token = jwt.sign({\n\tuser: oneUser._id,\n\texp: Math.floor(Date.now() / 1000) + (30) //30s后过期\n}, privateKey, { algorithm: 'RS256'})\n```\n\nprivatekey生成\n\n```\nssh-keygen -t rsa -b 4096 -f private.key #生成私钥\n# Don't add passphrase\nopenssl rsa -in private.key -pubout -outform PEM -out public.key #生成对应公钥\n# 生成公钥格式需要是PEM格式的, ss-keygen 也可以生成公钥\n# ssh-keygen -f public.key -e -m pem  \ncat private.key\ncat public.key\n```\n\n##### 验证token\n\n`jwt.verify(token, secretOrPublicKey, [options, callback])`\n\n```javascript\nvar publicKey = fs.readFileSync(config.publicKey)\ntry {\n  result = jwt.verify(token, publicKey) \n} catch(e) {}\n```\n\n#### 客户端\n\n在每次发起需验证请求时在头部携带JWT格式的token\n\n```\nAuthorization: Bearer <token>\n```\n\n### 优点\n\n> - 体积小，因而传输速度快\n> - 传输方式多样，可以通过 URL/PosT 参数/HTTP 头部 等方式传输\n> - 严谨的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化\n> - 支持跨域验证，多应用于单点登录。\n> - 充分依赖无状态 API ，契合 RESTful 设计原则\n> - 验证解耦，无需使用特定的身份验证方案，易于实现分布式\n> - 比 cookie 更支持原生移动端应用\n\n## 单点登录实现\n#### 登录\n\n基于jwt的验证方式实现单点登录，只需要在单点（暂时称之为center）登录后通过一定方式将token分发给其他点。\n\ntoken的验证可以在center端统一处理，也可将上文提到的`publicKey`分发给各个点，各个点自行验证。\n\ntoken的各个点存储可以通过cookie、localstorage。\n\n![](/images/2017/06/jwt-2.png)\n\n#### 退出登录\n\n退出登录实现和登录类似，请求center退出登录页面，center清理各个点的cookie或者localstorage实现退出登录。\n## 参考资料\n\n[5 Easy Steps to Understanding JSON Web Tokens (JWT)](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)\n\n[Introduction to JSON Web Tokens](https://jwt.io/introduction/)","tags":["web development"]},{"title":"通过 Webpack打包，了解不同的“模块定义”","url":"/2017/05/27/tong-guo-webpackda-bao-liao-jie-bu-tong-de-mo-kuai-ding-yi/","content":"\n\t\n## webpack 打包输出方式\n\n在webpack config中有两个属性\n\n### `output.library`  设置打包输入的library名\n\n### `output.libraryTarge` 设置打包方式\n\n* `var`  var MyLibrary = _entry_return_; (默认)\n\n* `this`  this[\"MyLibrary\"] = _entry_return_;\n\n* `window`  window[\"MyLibrary\"] = _entry_return_;\n\n* `global`  global[\"MyLibrary\"] = _entry_return_;\n\n* `commonjs` exports[\"Library\"] = xxx\n\n* `commonjs2` module.exports = xxx\n\n* `amd`  Export to AMD\n\n* `umd` Export to AMD, CommonJS2 or as property in root\n\n  当配置为`this` `commonjs` 时而没有设置 `output.library` 打包时会复制导出对象的每个属性，即将每个属性都绑定到 this 或者 exports。\n\n  `var` 和 `this` 方式适合在浏览器中直接运行，通过src方式引入的话，其实两者都是将Library帮到到了window。\n\n  `commonjs`  适用于用标准commonjs引入\n\n  `commonjs2` 适用于Node.js\n\n  `amd` 适用于requireJs\n\n  `umd` 同时支持了 AMD, CommonJS2, CommonJS 和 绑定到全局变量的方式（浏览器运行）\n\n  会有类似下面代码做各种模块加载支持\n\n\n         !function(e, t) {\n           \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() :\n           \"function\" == typeof define && define.amd ? define([], t) : \n           \"object\" == typeof exports ? exports.Iceter = t() : e.Iceter = t()\n        }(this, function()) {}\n\n  ## AMD、CommonJS、UMD\n\n  ### AMD\n\n  Asynchronous module definition (异步模块定义)，多用于浏览器端，典型的实现RequireJS。AMD可以异步加载模块，即便相互依赖的模块也可以分别加载，在所有依赖加载完成后运行，这对于浏览器来说不会发生阻塞，对页面加载有重要意义。\n\n  ### CommonJS\n\n  CommonJS是同步加载模块，NodeJS的module算是CommonJS的部分的实现。因为是同步加载所以不适用于浏览器端。\n\n  Webpack里面提到的`commonjs` 完全符合CommonJS定义语法的输出，而像Node.js 用`module.export` 代替 `exports`并不完全符合CommonJS所以用`commonjs2`表示，这里只是Webpack对两种形式做的区分。\n\n  > CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过 `module.exports` 导出对外的变量或接口，通过 `require()` 来导入其他模块的输出到当前模块作用域中。\n\n  ### UMD\n\n  Universal Module Definition（通用模块定义）, 支持了 AMD, CommonJS2, CommonJS 和 绑定到全局变量的方式。\n\n  ​\n\n\n","tags":["web development"]},{"title":"前端框架对比与实现","url":"/2017/05/14/qian-duan-kuang-jia-dui-bi-yu-shi-xian/","content":"\n之前talk分享的PPT，对比一些主要的前端类MVC框架（Vue2，Angular2，React）和实现\n<iframe src=\"//slides.com/weiweiggice/deck/embed\" width=\"100%\" height=\"720\" scrolling=\"no\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>","tags":["web development"]},{"title":"CSS Grid","url":"/2017/03/08/css-grid/","content":"\nCSS Grid 一种二维布局系统, 最初草案于2011年4月发布，最初在IE10上实现，通过`-ms-`使用。经过6年的探索和发展，17年有了较为稳定的候选版本，Firfox在52版本中实现了对[CSS Grid Layout Module Level 1](https://www.w3.org/TR/css-grid-1/)的支持，Chrome在57版本实现了支持，Safari在10.1版本实现支持。\n\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-12-06-32-PM.png)\n\n相比Flex Grid是为了解决二维布局问题，Flex则解决一维布局问题；在Grid诞生之前没有很恰当解决二维布局的方法，很久之前采用的是基于表格的布局方式，后来一般是采用float布局结合Flex等实现布局，但是这些都并非原属性设计的使用初衷，Grid才是一种更好的布局方案，随着草案的完善和浏览器的支持，之后肯定会得到广泛应用。\n\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-11-16-48-AM.png)\n\n# 概念和术语\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-5-59-21-PM.png)\n## Grid Lines\n指形成网格的水平和垂直线\n## Grid Tracks and Cells\nGrid Tracks 指相邻网格间的区域\nGrid Cells 指2个相邻行网格线和2个相邻列网格线之间的区域\nGrid Areas 由一或多个Cell组成的区域\n\n<iframe height='265' scrolling='no' title='CSS-GRID' src='//codepen.io/GGICE/embed/preview/ryjYLw/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/GGICE/pen/ryjYLw/'>CSS-GRID</a> by GGICE (<a href='http://codepen.io/GGICE'>@GGICE</a>) on <a href='http://codepen.io'>CodePen</a>.\n</iframe>\n\n# Grid Container 属性\n* display\n* grid-template-columns\n* grid-template-rows\n* grid-template-areas\n* grid-template\n* grid-column-gap\n* grid-row-gap\n* grid-gap\n* grid-auto-columns\n* grid-auto-rows\n* grid-auto-flow\n* justify-items\n* grid\n* justify-content\n* align-content\n* justify-items\n* align-items\n\n## `grid-template-columns 和 grid-template-rows`\n定义行列轨迹\n\n    grid-template-columns: none | <track-list> | <auto-track-list>\n    grid-template-rows: none | <track-list> | <auto-track-list>\n\n### `<track-list>`\n\n    [ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?\n\n#### `<track-size>`\n`<track-breadth>`\n\n* css 长度如px、%\n* flexible 长度如 1fr (比例分配剩余的空间) [🌰](https://igalia.github.io/css-grid-layout/breadth.html)\n* ` min-content` 字符，不超出边界的最小尺寸\n* `max-content` 字符，装配内容的所需的最小尺寸 [🌰](https://igalia.github.io/css-grid-layout/max-min-content.html)\n*  `auto` 字符，占据所有剩余的空间\n\n```\n.grid {\n  display: grid;\n  grid-template-columns: min-content max-content auto;\n}\n```\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-8-06-53-PM.png)\n\n`计算函数:`\n\n`minmax(<inflexible-breadth> , <track-breadth>)`\n\n可以是由minmax（）函数定义的范围，其中第一个值为最小值，第二个值为最大值。对于这种情况，最小值不能是flexible长度，因此您可以使用除flexible单位外的所有类型的值作为<track-breadth>。\n\n注意：在后期版本中可能支持第第一个最小值为flexible单位\n\n`fit-content(<length-percentage>)`\n\n表示公式min（max-content，max（auto，argument）），其计算类似于auto（即minmax（auto，max-content））。\n\n`auto`\n作为最大值时，等于`max-content`。作为最小值时，相当于`min-content`。\n注意：自动轨道大小（并且只有自动轨道大小）可以通过align-content和justify-content属性进行扩展。\n\n\n#### `<track-repeat>`\n利用一个repeat函数帮助我们实现一个很多行很多列的网格。\n```\nrepeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )\n```\n```\ngrid-template-columns: 30px 100px 30px 100px 30px 100px 30px 100px;\n\n/* same as above but with the repeat() function */\ngrid-template-columns: repeat(4, 30px 100px);\n```\n\n`<line-names>`\n\n给网格线添加一个名字，可以是除了`span` 以外的任意字符串，网格线可以有多个名字。\n\n```\ngrid-template-columns: [first sidebar-start] 250px [content-start] 1fr [last];\ngrid-template-rows: [first header-start] 100px [content-start] 1fr [footer-start] 100px [last];\n```\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-8-34-44-PM.png)\n[🌰](https://igalia.github.io/css-grid-layout/named-grid-lines.html)\n\n##`<auto-track-list>`\n\n```\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?\n\n```\n`<fixed-size>`\n\n1. `<fixed-breadth>`\n2. `minmax( <fixed-breadth> , <track-breadth> )`\n3. `minmax( <inflexible-breadth> , <fixed-breadth> )`\n\n`<fixed-repeat>`\n```\nrepeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\n```\n`<auto-repeat>`\n\n```\nrepeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )\n```\n`auto-fill` 生成尽可能多的列，以适应可用空间，而不会导致网格溢出。\n`auto-fit` 同上，区别在于将折叠任何空的重复轨道（这意味着它们的大小为0px）。\n\n## `grid-template-area`\n\n    grid-template-areas: none | <string>+\n\n此属性指定命名网格区域，还提供了网格结构的可视化，使得网格容器的总体布局更容易理解。\n\n#### `<string>+`\n\n每个单独的字符串创建一个行，而字符串中的每个单词创建一个列。所有字符串必须具有相同数量的单词，否则声明无效。使用一个或多个'.'的序列（U + 002E FULL STOP）表示空单元，其是网格中的未命名区域。\n\n```\n.grid-container {\n  display: grid;\n  grid-template-areas: \"logo stats\"\n                       \"score stats\"\n                       \"board board\"\n                       \"... controls\";\n}\n\n.logo { grid-area: logo; }\n.score { grid-area: score; }\n.stats { grid-area: stats; }\n.board { grid-area: board; }\n.controls { grid-area: controls; }\n```\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-9-04-58-PM.png)\n\n## `grid-template`\n\n```\ngrid-template: none | [ <‘grid-template-rows’> / <‘grid-template-columns’> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?\n```\n把 <‘grid-template-columns’>, <‘grid-template-rows’> and <‘grid-template-areas’>放置在一个属性中描述\n\n```\ngrid-template: [header-top] \"a a a\" [header-bottom] [main-top] \"b b b\" 1fr [main-bottom] / auto 1fr auto;\n```\n\n等于\n\n```\ngrid-template-areas: \"a a a\"\n                     \"b b b\";\ngrid-template-rows: [header-top] auto [header-bottom main-top] 1fr [main-bottom];\ngrid-template-columns: auto 1fr auto;\n```\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-9-11-13-PM.png)\n\n## `grid-column-gap` 和 `grid-row-gap`\n\n```\ngrid-column-gap: <length> | <percentage>\ngrid-row-gap: <length> | <percentage>\n```\n\n## `grid-gap`\n\n```\ngrid-gap: <‘grid-row-gap’> <‘grid-column-gap’>?\n```\n若只声明grid-row-gap则grid-column-gap也为该值\n\n## ` grid-auto-columns` 和 `grid-auto-rows`\n\n```\ngrid-auto-columns: <track-size>+\ngrid-auto-rows: <track-size>+\n```\n当grid item的列或行未由<'grid-template-columns'>或<'grid-template-rows'>定义时，将创建隐含网格轨道以保存这些项。我们可以使用<'grid-auto-columns'>和<'grid-auto-rows'>属性来控制这些隐式网格轨道的大小。我们还可以为这些隐式网格轨道指定多个轨道大小。\n\n```\n.grid {\n  display: grid;\n  grid-template-columns: 150px 150px;\n  grid-auto-columns: 50px 100px;\n}\n\n.item {\n  grid-column: 8;\n}\n```\n\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-9-24-57-PM.png)\n\n## `grid-auto-flow`\n\n```\ngrid-auto-flow: [ row | column ] | dense\n```\n未明确定义放置在网格上的网格项，自动放置算法会自动放入这些项。此属性控制自动布置算法的工作原理。\n\n`row` 默认值，自动布置算法将通过填充每一行并根据需要添加新行来放置网格项。\n\n`column` 自动布置算法将通过填充每个列放置网格项，并根据需要添加新列\n\n`dense` 默认为稀松排列，该值设置为稠密排列，若设置则算法将尝试适合在网格中较早的填充\"孔\"。这将最小化网格中“孔”的发生率。[🌰](https://igalia.github.io/css-grid-layout/autoplacement.html)\n\n## `grid`\n\n```\ngrid: <‘grid-template’> | <‘grid-template-rows’> / [ auto-flow && dense? ] <‘grid-auto-columns’>? | [ auto-flow && dense? ] <‘grid-auto-rows’>? / <‘grid-template-columns’>\n```\n```\n<‘grid-template-rows’> / [ auto-flow && dense? ] <‘grid-auto-columns’>?\n\n.grid {\n  grid: 50px 75px / auto-flow;\n}\n\n/* is equivalent to */\n.grid {\n  grid-template-rows: 50px 75px;\n  grid-template-columns: none; /* cannot be set explicitly with this syntax form */\n  grid-template-areas: none; /* cannot be set explicitly with this syntax form */\n  grid-auto-rows: auto; /* cannot be set explicitly with this syntax form */\n  grid-auto-columns: auto;\n  grid-auto-flow: column; /* can only set dense or not */\n  grid-column-gap: 0; /* cannot be set explicitly with this syntax form */\n  grid-row-gap: 0; /* cannot be set explicitly with this syntax form */\n}\n```\n\n```\n[ auto-flow && dense? ] <‘grid-auto-rows’>? / <‘grid-template-columns’>\n\n.grid {\n  grid: auto-flow dense / 30% 100px;\n}\n\n/* is equivalent to */\n.grid {\n  grid-template-rows: none; /* cannot be set explicitly with this syntax form */\n  grid-template-columns: 30% 100px;\n  grid-template-areas: none; /* cannot be set explicitly with this syntax form */\n  grid-auto-rows: auto;\n  grid-auto-columns: auto; /* cannot be set explicitly with this syntax form */\n  grid-auto-flow: row dense; /* can only set dense or not */\n  grid-column-gap: 0; /* cannot be set explicitly with this syntax form */\n  grid-row-gap: 0; /* cannot be set explicitly with this syntax form */\n}\n```\n## `justify-content`\n\n```\njustify-content: center | start | end | space-between | space-around | space-evenly\n```\n![](/content/images/2017/03/justify-content.png)\n\n`space-around` 沿着行轴在网格容器内均匀分布网格轨道，使得每个网格轨道在其任一侧具有相等的空间，在任一端具有一半大小的空间。\n\n`space-between` 沿着行轴在网格容器内均匀地分布网格轨道，其中第一网格轨迹与网格容器的起始边缘齐平，并且最后一个网格轨迹与网格容器的结束边缘齐平。\n\n`space-evenly` 沿着行轴在网格容器内均匀分布网格轨道，使得任何2个相邻网格轨道之间的空间相同。\n\n## `align-content`\n```\nalign-content: center | start | end | space-between | space-around | space-evenly\n```\n## ` justify-items`\n```\njustify-items: center | start | end | stretch\n```\n![](/content/images/2017/03/justify-items.png)\n\n`stretch` 默认，填充网格区域的宽度\n[🌰](https://igalia.github.io/css-grid-layout/alignment-demo.html)\n## `align-items`\n```\nalign-items: center | start | end | stretch\n```\n\n# Grid Items 属性\n* grid-column-start\n* grid-column-end\n* grid-row-start\n* grid-row-end\n* grid-column\n* grid-row\n* grid-area\n* justify-self\n* align-self\n\n##  `grid-column-start`, `grid-column-end` and `grid-row-start`, `grid-row-end`\n\n通过参考特定的网格线来确定网格项中的网格位置。 grid-column-start / grid-row-start是item开始的网格线，grid-column-end / grid-row-end是item结束的网格线。\n\n```\ngrid-column-start: auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\ngrid-column-end: auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\ngrid-row-start: auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\ngrid-row-end: auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]\n```\n\n`auto` 默认值，没有为此属性指定网格线，因此项目将自动放置以填充网格，并且默认跨度为1。\n\n`<custom-ident>` 可以是网格线的数字索引，或命名的网格线。\n\n`[ <integer> && <custom-ident>? ]`  对于重复命名的网格线，整数值n将定义具有指定名称的第n个网格线。整数值不能为0。\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-10-14-06-PM.png)\n```\n.a { grid-column-start: 1 bar; grid-column-end: 3 foo; }\n.b { grid-column-start: 1 bar; }\n.c { grid-column-start: -1 foo; }\n```\n\n`[ span && [ <positive-integer> || <custom-ident> ] ]`  提供指定网格项目的网格跨度的选项。此值与指定的网格线一起将确定网格项的位置。网格项将从指定的网格线跨越N个轨道。\n\n![](/content/images/2017/03/Screen-Shot-2017-03-09-at-10-17-55-PM.png)\n\n```\n.item{\n   grid-column-start: span 2;\n   grid-column-end: 4;\n}\n```\n如果 integer 不指定则默认为1\n\n##  `grid-row` 和 `grid-column`\n```\ngrid-row: <grid-line> [ / <grid-line> ]?\ngrid-column: <grid-line> [ / <grid-line> ]?\n```\n这是在同一声明中为相应维度设置起始行和结束行的缩写。 grid-row属性是grid-row-start和grid-row-end的缩写，而grid-column属性是grid-column-start和grid-column-end的缩写。\n网格线值由斜杠分隔。斜线之前的值表示开始网格线，斜线后的值表示结束网格线。\n\n## `grid-area`\n```\ngrid-area: <grid-line> [ / <grid-line> ]{0,3}\n```\n此缩写的顺序是row start / column-start / row-end / column-end\n\n## ` justify-self`[🌰](https://igalia.github.io/css-grid-layout/demo-alignment.html)\n```\njustify-self: center | start | end | stretch\n```\n\n## `align-self`\n```\nalign-self: center | start | end | stretch\n```\n# 栗子\n响应式布局\n\n<iframe height='265' scrolling='no' title='CSS-GRID-Responsive' src='//codepen.io/GGICE/embed/jBByzr/?height=265&theme-id=dark&default-tab=html,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/GGICE/pen/jBByzr/'>CSS-GRID-Responsive</a> by GGICE (<a href='http://codepen.io/GGICE'>@GGICE</a>) on <a href='http://codepen.io'>CodePen</a>.\n</iframe>\n经典blog界面\n<iframe height='265' scrolling='no' title='CSS-GRID-BLOG' src='//codepen.io/GGICE/embed/EWWZJR/?height=265&theme-id=dark&default-tab=html,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/GGICE/pen/EWWZJR/'>CSS-GRID-BLOG</a> by GGICE (<a href='http://codepen.io/GGICE'>@GGICE</a>) on <a href='http://codepen.io'>CodePen</a>.\n</iframe>\n在z轴上的布局\n<iframe height='265' scrolling='no' title='CSS-GRID-BLOG' src='https://igalia.github.io/css-grid-layout/z-index.html' style='width: 100%; border: 1px solid #000;'>\n</iframe>\n# 参考\n\n[CSS Grid Layout Module Level 1](https://www.w3.org/TR/css-grid-1/)\n\n[css-tricks](https://css-tricks.com/snippets/css/complete-guide-grid/)\n\n[Codrops CSS Reference](https://tympanus.net/codrops/css_reference/grid/)\n\n[Grid by Example](https://igalia.github.io/css-grid-layout/)\n","tags":["web development"]},{"title":"Let's Encrypt 免费好用的 HTTPS 证书 （Raspberry pi）","url":"/2016/10/08/lets-encrypt-mian-fei-hao-yong-de-https-zheng-shu-raspberry-pi/","content":"\nLet's Encrypt 被称为个人HTTPS的最佳解决方案，得到Mozilla、CISCO、Chrome、Facebook 等众多企业组织的支持。Let's Encrypt 也提供一套简单的HTTPS配置方案。\n\n![](/content/images/2016/10/-----2016-10-09---12-12-37.png)\n\n本文简单分享下安装 Let's Encrypt HTTPS证书过程，机器为Raspberry pi 3 ，系统为 Debian7，服务器软件为Nginx。\n\n## 安装 cerbot-auto\ncerbot-auto 是 Let's Encrypt 的自动化安装工具。\n\n    wget https://dl.eff.org/certbot-auto  \n    chmod a+x certbot-auto\n\n## 使用\n待安装完成之后\n\n    ./certbot-auto certonly --standalone -d x21.xyz -d center.x21.xyz\n\n-d 之后是跟随配置域名，子域名可使用多个-d ，Let's Encrypt 不支持泛域名所以要设置每一个子域名, 回车后将会出现图形界面，输入邮箱等设置信息。\n\n注意： 使用前记得停掉Nginx，其他占用80或者443端口的程序也需要停掉，certbot-auto 认证需要这两个端口。\n\n## 配置nginx\n\ncenter.x21.xyz 域名的配置实例\n\n    server {\n        listen 80;\n        listen [::]:80;\n        server_name center.x21.xyz;\n        return 301 https://$host$request_uri;\n    }\n    server {\n    \tlisten 443 ssl;\n        listen [::]:443 ssl;\n    \tserver_name center.x21.xyz;\n\n    \tssl_certificate /path/fullchain.pem; #生成的fullchain.pem 路径\n        ssl_certificate_key /path/privkey.pem; #生成的privkey.pem 路径\n        ssl_session_timeout 1d;\n        ssl_session_cache shared:SSL:50m;\n        #ssl_session_tickets off;\n\n    \tssl_dhparam /etc/nginx/ssl/dhparam.pem;\n        # dhparam.pem 生成方法\n        # $ sudo mkdir /etc/nginx/ssl\n        # $ sudo openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048\n\n    \tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    \tssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-A    ES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-A    ES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:    AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';\n    \tssl_prefer_server_ciphers on;\n\n    \tadd_header Strict-Transport-Security max-age=15768000;\n    \tssl_stapling on;\n        ssl_stapling_verify on;\n\n    \tresolver 8.8.8.8 8.8.4.4;\n\n    \tlocation / {\n            \tproxy_set_header   X-Real-IP $remote_addr;\n            \tproxy_set_header   Host      $http_host;\n            \tproxy_pass         http://127.0.0.1:9901;\n    \t}\n\n    }\n\n## HTTPS 配置文件生成器\n\nMozilla 有一个HTTPS配置文件的生成器[Mozilla SSL Configuration Generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/)\n\n上面的nginx便是配置借鉴Mozilla SSL Configuration Generator，但是nginx version: nginx/1.6.2, 一些特性并不支持，删减了一些配置 (一些nginx配置并不了解用途😭)。\n\n## 测试HTTPS配置，评分\n[Qualys SSL Labs](https://www.ssllabs.com/ssltest/index.html)提供了全面的 SSL 检测和评级，可以根据评测报告修改HTTPS配置。\n\n上面的配置已经获得了A+\n\n![](/content/images/2016/10/-----2016-10-09---12-14-31.png)\n\n## 自动更新证书\n\nLet's Encrypt 证书的期限是3个月，到期之后需要续期，借助cerbot-auto工具可以实现自动更新。\n\n使用 crontab 配置自动任务\n\n    sudo crontab -e\n\n添加以下内容\n\n    56 0,3 * * * /usr/bin/certbot renew --quiet --no-self-upgrade\n\n每天0点和3点执行一次更新证书命令 （cerbot-auto 推荐每天检查两次）\n","tags":["soft","linux"]},{"title":"查找MAC硬盘空间占用，清理","url":"/2016/08/20/cha-zhao-macying-pan-kong-jian-zhan-yong-qing-li/","content":"\n## 2016年10月09日10:21:22 更新：\n\nMacos sierra 10.12 版本之后，已经自带硬盘空间管理工具！\n\n## OLD\n\n之前在知乎上看到的方法，在每次128G MAC硬盘告急的时候，屡试不爽。\n\nncdu 是一个可以查看目录下所有文件文件夹大小，并提供完整统计结果的软件。所以我们可以根据ncdu的统计结果找出我们磁盘空间都被那些占用了，然后删除那些无关紧要的，回收空间。\n\n\n1. 安装 ncdu\n\n   brew install ncdu\n\n\n2. 检索所有目录\n\n    cd /    \n    sudo ncdu\n\n\n3. 等待结果\n\n    可能需要经过漫长时间（几十分钟）的等待，ncdu会检索所有文件完成。\n","tags":["os","Mac os X"]},{"title":"模拟Contextmenu事件","url":"/2016/08/20/mo-ni-contextmenushi-jian/","content":"\n## 新建一个鼠标事件并初始化\n\n\n    var myEvt = document.createEvent('MouseEvents');\n    myEvt.initMouseEvent(\n      'click'          // event type\n      ,true           // can bubble?\n      ,true           // cancelable?\n      ,window      // the event's abstract view (should always be window)\n      ,1              // mouse click count (or event \"detail\")\n      ,100           // event's screen x coordinate\n      ,200           // event's screen y coordinate\n      ,100           // event's client x coordinate\n      ,200           // event's client y coordinate\n      ,false         // whether or not CTRL was pressed during event\n      ,false         // whether or not ALT was pressed during event\n      ,false         // whether or not SHIFT was pressed during event\n      ,false         // whether or not the meta key was pressed during event\n      ,1             // indicates which button (if any) caused the mouse event (1 =      primary button)\n     ,null          // relatedTarget (only applicable for mouseover/mouseout events)\n    );\n\n\n## 使用伪造的事件\n\n当我们有了伪造的Event之后我们就可以去主动触发某个元素的的contentMenu事件，然后传入该Event。\n当然不仅仅是contentMenu事件可以模拟触发。\n\n## 拓展阅读\n\n[document.createEvent](https://developer.mozilla.org/en-US/docs/Web/API/Document/createEvent)\n\n[Creating_and_triggering_events](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events)\n","tags":["web development"]},{"title":"Linux 下类Alfred应用Mutate","url":"/2016/05/07/li/","content":"\nMutate是一款类似Mac os x 下面Alfred的程序，对于转战Linux的 Mac党这款应用必不可少。\n\n![](/content/images/2016/05/af.png)\n\n貌似是国人开发的，也是开源的。\n\n[GITHUB地址](https://github.com/qdore/Mutate)\n","tags":["soft","linux"]},{"title":"ubuntu 下安装 photoshop cs6 || cc","url":"/2016/05/07/ubuntu-xia-an-zhuang-photoshop-cs6/","content":"\n根据wine官网的说明，在wine1.9.8 的版本是可以安装photoshop cc的。[这里](https://appdb.winehq.org/objectManager.php?sClass=version&iId=29832&iTestingId=83387)有官方的安装说明。\n\n![](/content/images/2016/05/2016-05-07-15-38-15-----.png)\n## 安装篇\n\n1. 安装wine 1.9\n\n        sudo add-apt-repository ppa:wine/wine-builds\n        sudo apt-get update\n        sudo apt-get install --install-recommends wine-staging\n        sudo apt-get install winehq-staging\n\n\n之后可以按照官方的说法继续\n\n\n1. Installed \"Adobe Application Manager\" from http://www.adobe.com/support/downloads/detail.jsp?ftpID=4773\n2. Started Adobe Application Manager -> Waiting for the update -> Login with adobe account -> Shows only Photoshop CS6.\n3. Closed all instanced, run winecfg, set os to \"Windows 7\" (was XP on default)下载好\n4. Started the Application Manager -> Now shows Photoshop CC\n5. Installed Photoshop CC Via Application Manager\n(Optional components fail to install - however photoshop runs perfectly without that)\n6. Start Photoshop.exe with wine.\n\n我是直接，在第2. 直接安装了Photoshop CS6 因为个人来讲cs6 已经够我用的了，Adobe Application Manager 会直接把cs6下载好然后自动安装好，之后就可以在wine菜单中找的cs6的图标，直接点击就可以打开。\n\n## 激活篇\n\n   其实激活方法和Window找到cs6安装目录，然后...\n","tags":["soft","linux"]},{"title":"Linux mkdown编辑器 Haroopad","url":"/2016/04/01/ubuntu-mkdownbian-ji-qi/","content":"\nHaroopad 是一款跨平台的mkdown编辑器，难得的一款支持Linux系统的编辑器。界面简介，功能丰富，中文支持良好。\n\n![](/content/images/2016/05/2016-05-07-14-44-52-----.png)\n\n[官网](http://pad.haroopress.com)\n\n[下载地址](http://pad.haroopress.com/user.html)\n","tags":["soft","linux","os"]},{"title":"HTTP 缓存","url":"/2016/02/24/http-huan-cun/","content":"\n现在的网络环境相比以前已经变得很好，其实不是太大的网页应用，不是运行在4G以下模式的手机上，一些速度优化的作用越来越少，一些沿用很久的优化理论可能已经不实用。\n\n我希望提供更多具有时代意义的优化建议，本文主要借鉴[这篇](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn) 文章的优化建议。\n\n## 良好的HTTP缓存\n### 1.使用Etag 验证缓存的相应\nETag的原理是，在请求文件时，服务器会生成并返回一个随机令牌（一般为文件哈希值）。客户端在下次请求时将令牌发送给服务器，如果令牌一致，则跳过下载。\n\n客户端会先校验ETag若相应未被修改，则在延用Cache-Control的设置时间。\n\n在HTML5 Boilerplate中给出了流行服务器的[配置样例](https://github.com/h5bp/server-configs)。\n### 2.确定网站的最佳缓存层级\n#### Cache-Control\n>每个资源都可以通过 Cache-Control HTTP 头来定义自己的缓存策略\nCache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久\n\n[Cache-Control W3c描述文档](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)\n\n> Cache-Control 头在 HTTP/1.1 规范中定义，取代了之前用来定义响应缓存策略的头（例如 Expires）。当前的所有浏览器都支持 Cache-Control，因此，使用它就够了。\n\n默认请求资源会被缓存的，我们可以通过设置来修改是否缓存和明确缓存方式。\n\nno-cache 表示必须咸鱼服务器确认返回的相应是否被更改,然后才能使用该响应来满足后续的请求。如果设置了验证令牌，no-cache会发起往返通讯来验证缓存的响应，如果未更改，则不下载。\n\nno-store 直接禁止浏览器和所有中继缓存（CDN）返回的任何版本的响应，每次都会下载完整的响应。\n\npublic 表示即使有关联的http认证，甚至响应状态码无法正常缓存，响应也可以被缓存，大多数情况下，public不是必须的，因为明确的缓存信息（如max-age）已表示响应可以被缓存。\n\nprivate 表示浏览器可以缓存private的响应，但是通常只为单个用户缓存，因此不允许任何中继缓存（如CDN）对其进行缓存。\n\nmax-age 该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒）。\n#### 缓存的层级关系\n下面这张图展示缓存的作用层级关系\n![](/content/images/2016/02/http-cache-decision-tree-1.png)\n#### 设置合理的缓存级别\n对于网页应用我们既有缓存来优化加载，又希望我们的更新能使用户立即获得，对于一些大型的网页应用，在大的版本迭代中，若不能配合server及时更新前端代码，还可能造成应用无法使用的情况。\n\n![](/content/images/2016/02/http-cache-hierarchy.png)\n\n* 这是一个典型的层级加载优化事例，在入口的Html文件我们设置no-cache，这意味着每次请求时都会重新验证文档，若内容改变，会获取最新的版本。同时若css，js文件修改，通过指纹码修改css和js文件的文件名，入口的Html文件会随之更新，下载新的版本。\n\n* 允许浏览器中继缓存 css 过期时间设置为1年。这是我们可以放心设置较长的时间，因为css的更新会同时更新网址，保证立即更新。\n\n* JavaScript 过期时间也设置为一年，但是被标记为private, 因为JavaScript可能包含一些个人数据，但是一般情况情况下private也是不需要的。\n* 缓存图片是不包含版本或指纹码，过期时间设为一天。 这样做是会存在风险图片不能及时更新，例如css引用的图片更新，为了及时更新我们也需要给图片添加指纹码，之后我们可以放心的设置较长的缓存时间。\n\n## 其他优化\n\n* 同一资源使用相同的网址\n* 利用CDN等中继缓存常用公共资源\n* 更新最小化，经常更新的部分，考虑单独拉出文件，仅作这部分更新\n\n## 问题&BUG\n\n上面所讲的理论在实践中，在不同浏览器、webview中并不一定如我们所愿的那样运作。可能会出现各种各样关于缓存的问题。在遇到具体问题时，会在下文具体分析解决。\n","tags":["web development","web development推荐方法"]},{"title":"JavaScript 内存管理和优化","url":"/2016/02/22/javascript-nei-cun-guan-li-he-you-hua/","content":"\n### 内存的生命周期\n\n1. 创建对象分配所需内存\n2. 使用该对象\n3. 当不被使用时释放\n\n### 老的垃圾回收机制\n\n老式的浏览器采用`引用计数算法垃圾回收`，对于循环引用的对象无法回收，已经基本废弃，这里不做讨论。\n\n### 现代浏览器垃圾回收机制\n\n现代浏览器采用`标记-清除算法垃圾回收`。这个算法，根据对象是否可以获得来确定是否回收。\n\n算法设置一个根对象，定时从根对象开始，查找所有根开始引用的对象，然后逐级向下查找，确定所有可以获得对象和所有无法获得的对象。\n\n这个算法解决了循环引用无法回收的问题，问题是无法被查询到的对象都会删除，可能存在小概率的误删。\n\n### 主动内存回收\n\n\tvar a = { some code }\n\ta = null //a对象内存将会被回收\n\n对于一些mvc框架，会主动控制视图或者控制器的生命周期，完成业务逻辑和提高运行效率。\n\n### 内存诊断工具\n\nChrome 的 Profiler\n\n### V8 引擎的垃圾回收\n\n[这里](http://alinode.aliyun.com/blog/14)有篇文章介绍v8引擎的垃圾回收机制\n\n### 代码优化\n\n#### 善用函数\n使用匿名包裹页面，可以利于内存的回收。\n\n\t;(function() {\n\t  // 主业务代码\n\t})();\n\n#### 避免全局变量\n默认情况下，全局变量是不会被回收的。\n\n#### 主动解除引用\n对于，明确的业务流程可以在恰当的时间，主动解除变量引用来，使得被回收。\n\n#### 良好的闭包管理\n这里的largeStr 并不会被回收\n\n\tvar a = function () {\n\t    var largeStr = new Array(1000000).join('x');\n\t    return function () {\n\t        return largeStr;\n\t    };\n\t}();\n\n这里的largeStr 是会被回收的\n\n\tvar a = function () {\n\t    var smallStr = 'x';\n\t    var largeStr = new Array(1000000).join('x');\n\t    return function (n) {\n\t        return smallStr;\n\t    };\n\t}();\n\n所以在闭包的使用时，应该合理的设置返回值，并且关注返回值的回收。\n","tags":["web development","web development推荐方法"]},{"title":"移动端开发的单位选择","url":"/2016/02/22/yi-dong-duan-kai-fa-de-dan-wei-xuan-ze/","content":"\n## 名词\n\n1. 物理像素/设备像素 dp 即表示设备的屏幕真实尺寸。\n2. 逻辑像素 px 即表示设备宣称的分辨率\n3. 设备像素比 dpr 即 px/dp\n\n为什么在pc端设置的font-size=12px，在手机上看的时候却非常的小？就是因为电脑屏幕的dpr为1，但是手机却有着各种不同的dpr的值，想在手机上达到同等的视觉效果就需要font-size: 12px * dpr。\n\n这里提供了主流设备，包括主流手机、平板甚至手表的dp、px、dpr，方便开发和设计人员参考\n[device metrics](https://design.google.com/devices/)。\n\n## 获取 dpr\n\n可以通过window获取当前平台的dpr值\n\n\twindow.devicePixelRatio\n\n### 推荐的做法\n\n其实美好的响应式设计，在现实中的实现有时候并不是那么好。推荐使用[lib-flexible](https://github.com/ggice/lib-flexible) 来解决移动端的响应开发。\n\nlib-flexible 帮我们做了下面几件事\n\n 1. 元素的单位用rem，并在每个设备上面动态计算出rem的基准值，使得在各个设备上的显示效果一致\n 2. 字体单位用px, 并在每个设备上提供计算好的drp，通过形如下面的方法，使得字体的显示效果一致\n\n \t\tdiv {\n   \t\t\twidth: 1rem;\n   \t\t\theight: 0.4rem;\n   \t\t\tfont-size: 12px; // 默认写上dpr为1的fontSize\n\t \t}\n\n\t\t[data-dpr=\"2\"] div {\n   \t\t\tfont-size: 24px;\n\t\t}\n\n\t\t[data-dpr=\"3\"] div {\n    \t\tfont-size: 36px;\n\t\t}\n\n### 更好的方法\n\nflexible 布局方案其实在平板等大尺寸的屏幕，或者横屏状态保留很多的白边部分，这个问题，在传统通过百分比实现响应式布局中是不存在这个问题的。而且设计稿rem的换算可能不是那么方便，而且对于多栏布局，rem的值出现小数也会是头疼的问题，为此不得不又写了个makegrid.js去处理栅格系统。\n\nweb标准的制定过程可能没有更好的考虑响应式设计的良好支持，所以就出现了各种解决方案，各有优劣。\n\n接下来我们需要更好的解决方案，或者基于浏览器、web标准的支持方案。\n","tags":["web development","web development推荐方法"]},{"title":"Atom 插件主题推荐","url":"/2016/02/15/atom-cha-jian-zhu-ti-tui-jian/","content":"\n## 插件推荐\n\n* [linter](https://atom.io/packages/linter)  代码检查\n* [linter-jshint](https://atom.io/packages/linter-jshint) jshint检查\n* [atom-beautify](https://atom.io/packages/atom-beautify) 代码规整\n* [emmet](https://atom.io/packages/emmet) 快速前端代码生成工具 [教程](http://www.w3cplus.com/tools/emmet-cheat-sheet.html)\n* [seti-icons](https://atom.io/packages/seti-icons) 给文件加上小图标\n\n## 主题推荐\n\n* [seti-ui](https://atom.io/themes/seti-ui) 给文件加上小图标,安装seti-icons可以忽略\n* [seti-syntax](https://atom.io/themes/seti-syntax) 楼上配套的\n* [atom-material-ui](https://atom.io/themes/atom-material-ui)  Google's Material Design 风格主题\n* [atom-material-syntax](https://atom.io/themes/atom-material-syntax) 楼上配套的\n* [obsidian-syntax](https://atom.io/themes/obsidian-syntax) 个人比较喜欢的代码主题\n","tags":["web development","soft"]},{"title":"vi 操作清单","url":"/2016/01/27/vi-cao-zuo-qing-dan/","content":"\n记录一些vi的操作\n\n###1. vi 清空所有内容\n\n    gg //调到首行\n    dG //全部删除\n\n###2. 光标移动操作\n\n    0 //移动到行首\n    $ //移动到行尾\n\n###3. 整行拷贝粘贴\n\n    yy //整行复制\n    dd //整行剪切\n    p //粘贴\n","tags":["others"]},{"title":"CSS 知识清单","url":"/2016/01/23/css-zhi-shi-qing-dan/","content":"\n记录一些用时还需要去检索用法的一些css属性。<small>部分内容可能是从他处粘贴过来，若有侵犯请告知！</small>\n\n注意：非标准属性会用 <code>*</code> 标注\n## 1 word-wrap word-break white-space\n\n### 描述：\nword-wrap、word-break为css3属性，分别定义允许长单词或 URL 地址换行到下一行；定义自动换行的处理方法；white-space 定义如何处理元素内的空白。\n\n值得说明的是，三者的定义会出现覆盖影响。\n\n### 取值：\n\nword-wrap 默认值 normal，会继承\n<table class=\"dataintable\">\n<tbody><tr>\n<th style=\"text-align: left\">值</th>\n<th style=\"text-align: left\">描述</th>\n</tr>\n\n<tr>\n<td>normal</td>\n<td>只在允许的断字点换行（浏览器保持默认处理）。</td>\n</tr>\n\n<tr>\n<td>break-word</td>\n<td>在长单词或 URL 地址内部进行换行。</td>\n</tr>\n</tbody>\n</table>\n\nword-break 默认值normal，会继承\n<table class=\"dataintable\">\n<tbody><tr>\n<th style=\"text-align: left\">值</th>\n<th style=\"text-align: left\">描述</th>\n</tr>\n\n<tr>\n<td>normal</td>\n<td>使用浏览器默认的换行规则。</td>\n</tr>\n\n<tr>\n<td>break-all</td>\n<td>允许在单词内换行。</td>\n</tr>\n\n<tr>\n<td>keep-all</td>\n<td>只能在半角空格或连字符处换行。</td>\n</tr>\n</tbody>\n</table>\n\nwhite-space 默认值 normal, 会继承\n<table class=\"dataintable\">\n<tbody><tr>\n<th style=\"text-align: left\">值</th>\n<th style=\"text-align: left\">描述</th>\n</tr>\n\n<tr>\n<td>normal</td>\n<td>默认。空白会被浏览器忽略。</td>\n</tr>\n\n<tr>\n<td>pre</td>\n<td>空白会被浏览器保留。其行为方式类似 HTML 中的 &lt;pre&gt; 标签。</td>\n</tr>\n\n<tr>\n<td>nowrap</td>\n<td>文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止。</td>\n</tr>\n\n<tr>\n<td>pre-wrap</td>\n<td>保留空白符序列，但是正常地进行换行。</td>\n</tr>\n\n<tr>\n<td>pre-line</td>\n<td>合并空白符序列，但是保留换行符。</td>\n</tr>\n\n<tr>\n<td>inherit</td>\n<td>规定应该从父元素继承 white-space 属性的值。</td>\n</tr>\n</tbody>\n</table>\n\n### 测试：\n\n<iframe width=\"100%\" height=\"300\" src=\"//jsfiddle.net/kxqgh11d/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n\n## *2 text-rendering\n\n### 描述：\n\nText-rendering 属性是一个非标准属性，本意是用来设置SVG的属性，之后Gecko/WebKit/Blink等内核也支持了普通DOM元素设置Text-rendering。\n主要用来告诉渲染引擎（rendering engine）渲染文字的时候如何来优化，浏览器根据这个属性来权衡速度、易读性、几何精度等方面。不同系统、不同浏览器的渲染引擎不同，效果不同。\n\n### 取值：\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: left\">值</th>\n      <th style=\"text-align: left\">描述</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><code>auto</code></td>\n      <td>浏览器用渲染速度、易读性、几何精度等自动优化来绘制文本，不同浏览器效果不同</td>\n\n    </tr>\n    <tr>\n      <td><code>optimizeSpeed</code></td>\n      <td>绘制文本时渲染速度优先，会禁用使用特殊的字距调整和某些字体的连字</td>\n    </tr>\n    <tr>\n       <td><code>optimizeLegibility</code></td>\n       <td>绘制文本时易读性优先，允许使用特殊的字距调整和某些字体的连字</td>\n    </tr>\n    <tr>\n       <td><code>optimizeLegibility</code></td>\n       <td>绘制文本时几何精度优先，可以使某些字体非间距非几何对称，达到更好的显示效果</td>\n    </tr>\n  </tbody>\n</table>\n\n### 其他：\n\n在大多情况话看不出明显区别，对一些特殊英文字体可能有效果！\n参考：[http://www.feeldesignstudio.com/2013/05/text-rendering/](http://www.feeldesignstudio.com/2013/05/text-rendering/)\n[http://www.feeldesignstudio.com/2013/05/text-rendering/](http://www.feeldesignstudio.com/2013/05/text-rendering/)\n","tags":["web development"]},{"title":"ubuntu 安装屏幕标尺 取色器","url":"/2015/11/08/ubuntu-an-zhuang-ping-mu-biao-chi-qu-se-qi/","content":"\n屏幕标尺：Screen Ruler\n\n安装方法：\n\n    apt-get install screenruler\n\n\n屏幕取色：gcolor\n\n安装方法：\n\n    apt-get install gcolor2\n\n","tags":["soft"]},{"title":"Nginx 开启Gzip 压缩","url":"/2015/10/29/nginx-kai-qi-gzip-ya-suo/","content":"\nNginx 开启Gzip:\n\n打开Nginx 配置文件,添加如下内容:\n\n    gzip on;\n    gzip_min_length 1k; #要压缩的最小文件大小\n    gzip_buffers 4 16k; #压缩缓冲大小设置\n    gzip_http_version 1.0; #注释1\n    gzip_comp_level 2;  #压缩级别,1-10，数字越大压缩的越好，打开时间也越长\n    gzip_types text/plain application/x-javascript text/css application/xml      text/javascript application/x-httpd-php image/jpeg image/gif image/png; #要压缩的文件类型\n    gzip_vary off; #注释2\n    gzip_disable \"MSIE [1-6]\\.\"; #IE6不支持Gzip,不给它压缩\n\n\n\n   注释1 :\n\n它的默认值是1.1，就是说对HTTP/1.1协议的请求才会进行gzip压缩\n如果我们使用了proxy_pass进行反向代理，那么nginx和后端的upstream server之间是用HTTP/1.0协议通信的\n     This module makes it possible to transfer requests to another server.\n     It is an HTTP/1.0 proxy without the ability for keep-alive requests yet. (As a result, backend connections are created and destroyed on every request.) Nginx talks HTTP/1.1 to the browser and HTTP/1.0 to the backend server. As such it handles keep-alive to the browser.\n     如果我们使用nginx通过反向代理做Cache Server，而且前端的nginx没有开启gzip\n     同时，我们后端的nginx上没有设置gzip_http_version为1.0，那么Cache的url将不会进行gzip压缩\n\n注释2:\n\n和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩\n\n\n[官方文档 Module ngx_http_gzip_module](http://nginx.org/en/docs/http/ngx_http_gzip_module.html)\n","tags":["soft","nginx"]},{"title":"gulp 顺序执行任务","url":"/2015/09/08/gulp-shun-xu-zhi-xing-ren-wu/","content":"\n默认情况下gulp任务是并行执行的。\n\n串行执行有几种方法\n\n1.用callback的方式\n\n    var gulp = require('gulp');\n\n    // 传入一个回调函数，因此引擎可以知道何时它会被完成\n    gulp.task('one', function(cb) {\n         // 做一些事 -- 异步的或者其他任何的事\n         cb(err); // 如果 err 不是 null 和 undefined，流程会被结束掉，'two' 不会被执行\n    });\n\n    // 标注一个依赖，依赖的任务必须在这个任务开始之前被完成\n    gulp.task('two', ['one'], function() {\n       // 现在任务 'one' 已经完成了\n    });\n\n2.返回steam\n\n    var gulp = require('gulp');\n    var del = require('del'); // rm -rf\n\n    gulp.task('clean', function(cb) {\n        del(['output'], cb);\n    });\n\n    gulp.task('templates', ['clean'], function() {\n        var stream = gulp.src(['src/templates/*.hbs'])\n        // 执行拼接，压缩，等。\n        .pipe(gulp.dest('output/templates/'));\n        return stream; // 返回一个 stream 来表示它已经被完成\n    });\n\n    gulp.task('styles', ['clean'], function() {\n        var stream = gulp.src(['src/styles/app.less'])\n        // 执行一些代码检查，压缩，等\n        .pipe(gulp.dest('output/css/app.css'));\n        return stream;\n    });\n\n    gulp.task('build', ['templates', 'styles']);\n\n    // templates 和 styles 将会并行处理\n    // clean 将会保证在任一个任务开始之前它完成\n    // clean 并不会被执行两次，尽管它被作为依赖调用了两次\n\n    gulp.task('default', ['build']);\n\n问题：为什么要返回steam？\n\n虽然在gulp.task('build', ['templates', 'styles']);数组中已经声明了依赖关系，但是这个依赖关系是只能保证前一个函数执行完毕，而它的文件操作等可能还未完成，所以需要以steam结束为依据。\n\n问题：1个task中有多个文件等steam操作，如何保证内部并行执行，并且监听所有steam均结束的状态？\n\n借助[event-steam](https://www.npmjs.com/package/event-stream)等工具，监听steam的结束。\n\n参考资料：\n\nhttp://www.gulpjs.com.cn/docs/recipes/running-tasks-in-series/\n\nhttp://www.lifelaf.com/blog/?p=1210\n\nhttps://www.npmjs.com/package/event-stream\n","tags":["web development"]},{"title":"Brackets 插件推荐","url":"/2015/09/07/brackets-cha-jian-tui-jian/","content":"\n1.Beautify 一键规整你的代码\n\n2.Emmet 加快打码速度，提供诸如div>ul>li的快捷生成代码\n\n3.Extension Highlighter 不同的文件后缀显示不同的颜色\n\n4.JSHint 检查JS\n\n5.tabs 把打开的文件列表从左边移动到头部\n\n6.Themes for Brackets 众多的主题\n\n7.Quick Search 选择一个单词，其他同名的也标注出来\n\n8.brackets-git 辅助GIT管理\n\n9.Brackets SASS Code Hints sass自动补全提示\n\n10.Brackets Icons 给每个文件都加上图标\n\n11.Interactive Linter 标注语法错误\n\n12.Markdown Preview mkdown 文件预览\n\n[Brackets插件库](https://brackets-registry.aboutweb.com/)\n[Brackets官网](http://brackets.io/)\n\n其他：\n\n1.在使用Brackts是安装插件有时会遇到\"Installation failed. Unknown internal error\". 的问题。出现这个问题的原因有很多。\n有些通过安装新版本可以解决。\n\n     ::1             localhost\n\n发现当hosts 设置了支持IPV6的::1 同样会引发这一问，注释掉可以解决。","tags":["web development","编辑器"]},{"title":"树莓派Raspberry pi 使用花生壳内网版","url":"/2015/08/27/shu-mei-pai-raspberry-pi-shi-yong-hua-sheng-ke-nei-wang-ban/","content":"\n可能花生壳推出针对Raspberry pi 客户端已经有一段时间，客户端支持内网版花生壳的。使用和安装也很简单。\n\n1.下载解压安装包\n\n    # wget http://hsk.oray.com/download/download?id=25 -O b.tgz\n    # tar zxvf b.tgz\n\n2.安装\n\n    # cd phddns2/\n    # ./oraynewph start\n\n如果一切顺利的话，便会出现如下的提示：\n\n    SN= *******\n    Oraynewph start success\n\n这就说明花生壳已经成功安装，并且运行了，记住你的SN码，因为登陆要用到。\n\n3.管理内网映射\n\n登陆 http://b.oray.com 输入你的SN码，绑定花生壳账号，即可进行内网映射。当然如果你想用自己的域名，想要稳定的服务，可能你需要购买花生壳的付费服务。\n\n另外\n\n可以映射到22端口，这样就可以在外网环境通过ssh登陆内网的raspberry pi。\n\nenjoy!\n","tags":["soft","raspberry pi"]},{"title":"Tickeys 找打字的感觉","url":"/2015/08/22/tickeys-zhao-da-zi-de-gan-jue/","content":"\nTickeys\n/*找对打字的感觉*/\n\n这是一款可以让你每次敲击键盘都会发出“优美”声音的软件，支持Mac、Windows 和 Linux。机械键盘加上Tickeys enjoy !\n\n![](https://dn-icegsimg.qbox.me/tickeys.png)\n\nTickeys 可是随时通过QAZ123打开设置，声音方案支持冒泡、打字机、机械键盘、剑气（为啥不支持自己导入声音方案？）。\n\n[官方下载](http://www.yingdev.com/projects/tickeys)\n","tags":["soft"]},{"title":"一台电脑管理多个SSH KEY","url":"/2015/08/16/-tai-dian-nao-guan-li-duo-ge-ssh-key/","content":"\n1.生成本地SSH KEY\n\n     ssh-keygen -t rsa -C \"your_email@example.com\"\n\n2.一台机器管理多个SSH KEY\n需要编辑文件（没有则新建）\n\n    vi ~/.ssh/config\n\n    Host personal.github.com  \n      HostName github.com  \n      User git  \n      IdentityFile ~/.ssh/personal_rsa  \n\n    Host work.github.com  \n      HostName github.com  \n      User git  \n      IdentityFile ~/.ssh/work_rsa\nHost： \"personal.github.com\"是一个\"别名\"，可以随意命名；\nHostName：比如工作的git仓储地址是git@code.sohuno.com:username/repo_name.git, 那么我的HostName就要填\"sohuno.com\"；\nIdentityFile： 所使用的公钥文件的位置;\n\n配置完毕可用测试下是否成功\n\n    ssh -T git@personal.github.com\n    ssh -T git@work.github.com\n    # 注： @符号后面的\"personal.github.com\"就是在~/.ssh/config文件中指定      的\"Host\"项\n    #若成功会返回欢迎信息\n2.1 其他方法\n连接时指定SSH KEY\n\n     ssh root@10.0.0.1 -i /path/to/your_id_rsa\n","tags":["soft"]},{"title":"Mac 下制作Ubuntu安装盘","url":"/2015/05/12/mac-xia-zhi-zuo-ubuntuan-zhuang-pan/","content":"\n为了装elementary os 0.3，查了一些将Ubuntu安装到移动硬盘的方法。最终找到一个在MAC比较简单的实现方法。\n\n1.将下载的*.iso 转换成 DMG\n\n     $ hdiutil convert -format UDRW -o ubuntu elementaryos-freya-amd64.20150411.iso\n     //把当前目录下的elementaryos-freya-amd64.20150411.iso 转换成名位Ubuntu的dmg\n\n2.插入U盘 解除挂载\n\n     diskutil list\n     //查看u盘挂载目录 可以看到类似 /dev/disk3\n     diskutil unmountDisk /dev/disk3\n     //解除挂载\n3.将镜像写入U盘\n\n     sudo dd if=ubuntu.img.dmg of=/dev/rdisk3 bs=1m\n\n然后开机选择U盘启动就好了。\n","tags":["soft"]},{"title":"elementary os 0.3","url":"/2015/05/12/elementary-os-0-3/","content":"\n在拥有这台白苹果之前，最喜欢的一款Linux系统，简洁、自然，有种MAC os类似浑然天成的感觉，有时候甚至会觉得她比MAC os更具有吸引力。开放的Linux可以自由的更换这种主题和图标，可以自己去编辑系统样式，像写CSS那样去写系统的界面。\n\n但是说到为什么不把Linux作为工作环境呢，MAC os还是相对稳定的系统，稳定才有效率可言，而MAC os有好多实用软件，效率软件。在MAC下面可以获得如window一般的软件支持，却没有window那样的浮夸，让我们可以静下心来做一些事情。\n\n新版的 Freya。\n\n主桌面：\n![](https://dn-icegsimg.qbox.me/desk.png)\n\n任务栏：\n![](https://dn-icegsimg.qbox.me/tab.png)\n\n多任务视图：\n![](https://dn-icegsimg.qbox.me/more.png)\n\n终端：\n![](https://dn-icegsimg.qbox.me/item.png)\n\n主机信息：\n![](https://dn-icegsimg.qbox.me/setting.png)\n\n新功能，message设置：\n![](https://dn-icegsimg.qbox.me/message.png)\n\n新功能，安全设置：\n![](https://dn-icegsimg.qbox.me/safe.png)\n","tags":["os"]},{"title":"HTML5 拖拽上传文件和文件夹","url":"/2015/05/12/html5-tuo-zhuai-shang-chuan-wen-jian-he-wen-jian-jia/","content":"\n拖拽动作会引发的一些事件：\n\n     dragstart：网页元素开始拖动时触发。\n     drag：被拖动的元素在拖动过程中持续触发。\n     dragenter：被拖动的元素进入目标元素时触发，应在目标元素监听该事件。\n     dragleave：被拖动的元素离开目标元素时触发，应在目标元素监听该事件。\n     dragover：被拖动元素停留在目标元素之中时持续触发，应在目标元素监听该事件。\n     drop：被拖动元素或从文件系统选中的文件，拖放落下时触发。\n     dragend：网页元素拖动结束时触发。\n\n##1.简单拖拽上传文件的实现\n\n###1.1 建立可拖拽元素\n\n\n    <div id=\"drop-zone\">Drop files here</div>\n\n###1.2 监听该元素的拖拽事件\n\n    function handleDragOver(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\n    }\n    var dropZone = document.getElementById('drop-zone');\n    dropZone.addEventListener('dragover', handleDragOver, false);\n\n###1.3 获得上传的文件\n\n     function handleFileSelect(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n        var files = evt.dataTransfer.files; // FileList object.\n    }\n    dropZone.addEventListener('drop', handleFileSelect, false);\n\n[简单上传文件的DEMO和源码查看](http://public.ice.gs/demo/drag/simpleUpFiles.html)\n\n###1.4 上传文件的兼容性\n\n    chrome 支持\n    safari 支持\n    IE10+  支持\n    Firefox 支持\n\n##2.拖拽上传文件夹(仅仅chrome支持)\n\n与上传文件夹不同的是我们对handleFileSelect函数进行改造\n\n    function handleFileSelect(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n        var files = [],\n            items = evt.dataTransfer.items;\n\n        function folderRead(entry){\n            showFolder(entry);\n            entry.createReader().readEntries(function (entries) {\n                for(var i = 0; i < entries.length; i++){\n                    var entry = entries[i];\n                    console.log(entry);\n                    if(entry.isFile){\n                        entry.file(function(file){\n                            show(file);\n                        })\n                    }else{\n                        folderRead(entry);\n                    }\n                }\n            });\n        }\n\n\n        for(var i = 0; i < items.length; i++){\n            var entry = items[i].webkitGetAsEntry();\n            if(!entry){\n                return;\n            }\n            console.log(entry);\n            if(entry.isFile){\n                entry.file(function(file){\n                    show(file);\n                })\n            }else{\n                folderRead(entry);\n            }\n        }\n\n        function show(f){\n            var tpl = '<li><strong>'+ f.name + '</strong> || '\n                + f.size +' bytes || last modified: ' +\n                f.lastModifiedDate.toLocaleDateString() + '</li><li></li>';\n            var lis = document.getElementsByTagName('li');\n            lis[lis.length-1].innerHTML = tpl;\n        }\n        function showFolder(f){\n            var tpl = '<li><strong>'+ f.name + '</strong></li><li></li>';\n            var lis = document.getElementsByTagName('li');\n            lis[lis.length-1].innerHTML = tpl;\n        }\n    }\n\n通过items[i].webkitGetAsEntry()获取文件夹文件信息，然后通过递归调用遍历文件内容。\n\n其中最终读取文件、文件夹信息是调用的HTML5的文件API。\n\n[上传文件夹演示和源码查看](http://public.ice.gs/demo/drag/dragFolder.html)\n\n##参考资料\n<li>[File API 规范](http://www.w3.org/TR/file-upload/)\n<li>[File Reader API 规范](http://www.w3.org/TR/file-upload/#dfn-filereader)\n<li>[使用File API 读取文件](http://www.html5rocks.com/zh/tutorials/file/dndfiles/)\n","tags":["web development"]},{"title":"AMD、CMD 和 CommonJS的区别","url":"/2015/03/27/requirejs-he-commonjsde-qu-bie/","content":"\n#####AMD 与 CommonJS\n\nNode.js的模块系统是参照CommonJs规范实现的，RequireJS是参照AMD规范实现的。\n\nCommonJS使用exports对象来定义模块。\n\nAMD中使用define,在模块加载之前声明依赖。\n\nAMD更适合浏览器，因为它支持异步加载模块依赖。\n\nrequireJS在实现AMD的同时，还提供了一个CommonJS包裹，这样CommonJS模块可以几乎直接被RequireJS引入。\n\n\tdefine(function(require, exports, module) {\n    var someModule = require('someModule'); // in the vein of node    \n    exports.doSomethingElse = function() { return       someModule.doSomething() + \"bar\"; };\n\t});\n\n#####AMD 与 CMD\n\nSeaJS是参照CMD思想实现的。\n\n知乎上面简洁明了的回答：\n\n<table border=\"1\">\n<tr>\n<th>方案</th>\n<th>优势</th>\n<th>劣势</th>\n<th>特点</th>\n</tr>\n<tr>\n<td>AMD</td>\n<td>速度快</td>\n<td>会浪费资源</td>\n<td>预先加载所有的依赖，直到使用的时候才执行</td>\n</tr>\n<tr>\n<td>CMD</td>\n<td>只有真正需要才加载依赖</td>\n<td>性能较差</td>\n<td>直到使用的时候才定义依赖</td>\n</tr>\n</table>\n\n[CMD定义规范](https://github.com/seajs/seajs/issues/242)\n\n[AMD定义规范](https://github.com/amdjs/amdjs-api/wiki/AMD)\n\n[SeaJS与RequireJS的不同](https://github.com/seajs/seajs/issues/277)\n","tags":["web development","模块加载器"]},{"title":"Mac 10.10.3下使用Phonegap打包android程序","url":"/2015/01/22/test/","content":"\n最近想借鉴之前公司的HTML5架构，自己做一个可用的HTML5框架，实现简单的移动端应用开发。\n\n最后一环的打包Android或者Ios程序自然就想到了Phonegap了。简单分享下运行Hello World的过程。\n\n需要的东西有：JDK1.6(以上)，ant，node.js，Android sdk\n\n######安装必要的工具：\n\n1.JDK1.6（Mac 自带）。\n2.ant\n\n\tbrew install ant\n\n3.node.js （[官方下载](http://nodejs.org/download/)）。\n4.Android sdk ([官方下载](http://developer.android.com/sdk/installing/index.html)只需要下载SDK即可)。\n安装： 将下载的文件解压到某个目录，打开tools目录下面的android。\n如下图选择安装,既可以保证顺利打包所需的。\n![](https://dn-icegsimg.qbox.me/android.png)\n设置环境变量：\n\n    vi ~/.bash_profile\n\t//加入以下内容 注意目录换成自己存放sdk的目录\n\t export PATH=${PATH}:/Development/adt-bundle/sdk/platform-tools:/Development/adt-bundle/sdk/tools\n更新环境变量：\n\n    $ source ~/.bash_profile\n\n5.Phonegap\n\n\tsudo npm install -g phonegap\n\n######运行Hello world\n\n    $ cordova create hello\n    $ cd hello\n    $ cordova platform add android\n    $ cordova build\n\n一切顺利的话，你将会看到打包好的apk程序。\n","tags":["web development","soft"]},{"title":"远程调试工具weinre","url":"/2014/12/08/yuan-cheng-diao-shi-gong-ju-weinre/","content":"\n做移动端开发或者hybrid的开发可能在前端调试中会遇到这样两个场景:\n\n1.在各种手机浏览器中调试，不是所有的浏览器都可以console.log出东西的。\n\n2.在APP中，不是所有的APP都可以console.log出东西的。\n\n那么我需要一个东西可以，可以console.log东西，不管前端在哪里运行，不不仅仅是这些，我们还需要一个强大的可以像在PC中调出console那么强大东西来。weinre就是这样的一个不错选择。\n\n[官方网站](http://people.apache.org/~pmuellr/weinre-docs/latest/Home.html) （具体使用方法参见官方文档，写的很清楚。）\n\n我做了一个公共的Weinre代理服务，任何人都可以通过[点我](http://weinre.ice.gs/),实现远程调试，而不需要自己搭建服务。\n\n\n(其实weinre在上家公司做移动开发的时候已经而耳闻weinre,现在才意识到它的强大！赶脚老是跟不上步伐！)\n","tags":["web development"]},{"title":"PC端前端开发兼容性测试方案","url":"/2014/11/18/pcduan-qian-duan-kai-fa-jian-rong-xing-ce-shi-fang-an/","content":"\n近3个月百度统计的浏览器市场份额（360浏览器被“分割”为对应内核的浏览器）\n\n![](https://dn-icegsimg.qbox.me/ie.jpg)\n\n做PC开发已经有两年多了，PC端的兼容性问题在之前一直受IE6的困扰，变得非常困难。如今已经越来越多的公司包括国内公司放弃支持IE6,之前我做兼容性测试的时候是虚拟机xp + ie6 、虚拟机win7 + ie8 、虚拟机win7 + ie9、 win8.1+ie11。\n\n如今，环境已经改变，我们可以只做兼容到IE8的处理，我个人也非常赞成这么做。\n\n######比较简单的兼容性测试方案：\n\nIetester + IE11\n\n总所周知Ietester，可以做查看网站在IE版本下的情况，但是它并不准确，只是可以粗略的显示一下情况。\n\nIE11，F12开发者工具中可以调整模拟IE浏览器版本，它比Ietester能更准确的显示真实的状况。\n\n######建议的解决方案：\n\n我们考虑到兼容性问题的话，个人建议只需要考虑这几种浏览器：Chrome 、 Firefox 、safari、IE11、IE9、IE8。\n\n虽然不同操作系统间的相同浏览器也会出现不同的渲染表现，但是这种情况同样非常少。所以在建议解决方案中，只考虑浏览器版本。\n\nChrome、Firefox、safari你可以在一个系统中拥有他们。\nIE11、IE9、IE8 可以在 [modern.IE](https://www.modern.ie/zh-cn/virtualization-tools#downloads)中下到带有不同版本IE浏览器的虚拟机系统。\n\n######严谨的解决方案：\n\n目前[modern.IE](https://www.modern.ie/zh-cn/virtualization-tools#downloads)提供9种操作系统和IE浏览器的组合，可以安装这9个虚拟机，分别测试9中环境下的兼容性问题。\n\n然后再加上Chrome、Firefox、safari的兼容性测试。\n\n######国内情况\n\ncnzz 8月份浏览器市场份额的统计\n\n![](https://dn-icegsimg.qbox.me/iecnzz.png)\n\n可以看出360浏览器还占据很大份额，搜狗、腾讯、2345、猎豹、遨游等也占有一定的市场份额，虽然它们大多数内核是基于以上所说的主流浏览器，可是非常不幸的是，在你确定兼容所以主流浏览器的时候，可以你在这些国产浏览器中并不能正确的渲染。\n\n所以，我们有时候还需调整对这些国产浏览器的兼容性，起码市场份额较大的360和搜狗我们要考虑完美兼容它们。\n","tags":["web development"]},{"title":"携程5.9APP发布Summary","url":"/2014/09/12/xi-cheng-5-9appfa-bu-summary/","content":"\n实习的第一个项目随着携程5.9今天正式封包准备发布。第一次参与移动端HTML5的开发，第一次写大批量的JS代码。第一次开发2亿用户的应用！\n\n但是我觉得发布之后，应该留下些经验之谈。\n\n1.开发前期做好规范、选好框架。\n2.越早发现BUG，修改成本越低。这就要认真写好每一段代码！\n3.制定自己的封包，自测时间和临界点，在大版本测试前应该已经完成自己封包自测。\n4.注重资料查阅，避免，移动端开发的坑。\n5.解决问题的方式多样，有时可以战略性放弃。\n6.制定好开发计划。\n\n\n\t\t\t\t\t\t\t\t\t\t\tBY GGICE\n                                    2014年09月12日21:28:23\n 5.9&&5.8发布纪念章！\n ![](http://iceink.qiniudn.com/ctrip.png)\n","tags":["work"]},{"title":"最漂亮的中文字体–造字工房","url":"/2014/04/21/e69c80e6bc82e4baaee79a84e4b8ade69687e5ad97e4bd93-e980a0e5ad97e5b7a5e688bf/","content":"\n造字工房目前出品了16款漂亮的中文字体，反正这是我接触过的字体中最漂亮的中文字体了！\n\n<a href=\"http://www.makefont.com/\" target=\"_blank\">官方网站</a>\n\n文研 朗倩 形黑 力黑 映画 情书 朗宋 劲黑 雅圆 版黑 悦黑 尚黑 悦圆 俊雅 尚雅 丁丁手绘 16款造字工房 <a href=\"http://pan.baidu.com/s/1dDoYzp3\" target=\"_blank\">字体打包下载</a> （比在官网下载一个一个解压方便额！）。\n","tags":["soft"]}]